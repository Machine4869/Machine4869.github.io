<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Netty项目-仿写微信 IM 即时通讯系统(2) | 哑舍</title><meta name="description" content="Netty项目-仿写微信 IM 即时通讯系统(2)"><meta name="keywords" content="Netty"><meta name="author" content="Machine"><meta name="copyright" content="Machine"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/cat2.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Netty项目-仿写微信 IM 即时通讯系统(2)"><meta name="twitter:description" content="Netty项目-仿写微信 IM 即时通讯系统(2)"><meta name="twitter:image" content="https://machine4869.gitee.io/img/default_p5.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="Netty项目-仿写微信 IM 即时通讯系统(2)"><meta property="og:url" content="https://machine4869.gitee.io/2019/07/28/20190728161454796/"><meta property="og:site_name" content="哑舍"><meta property="og:description" content="Netty项目-仿写微信 IM 即时通讯系统(2)"><meta property="og:image" content="https://machine4869.gitee.io/img/default_p5.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://machine4869.gitee.io/2019/07/28/20190728161454796/"><link rel="prev" title="Netty项目-仿写微信 IM 即时通讯系统(3)" href="https://machine4869.gitee.io/2019/08/09/20190809142144254/"><link rel="next" title="Netty项目-仿写微信 IM 即时通讯系统(1)" href="https://machine4869.gitee.io/2019/07/22/20190722161728334/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://machine4869.gitee.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">哑舍</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 豆瓣电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片墙</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">134</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">45</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 豆瓣电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片墙</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#pipeline-与-channelHandler"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">pipeline 与 channelHandler</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#pipeline-与-channelHandler-的构成"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">pipeline 与 channelHandler 的构成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#channelHandler-的分类"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">channelHandler 的分类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ChannelInboundHandler-的事件传播"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">ChannelInboundHandler 的事件传播</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ChannelOutboundHandler-的事件传播"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">ChannelOutboundHandler 的事件传播</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#实战：构建客户端与服务端-pipeline"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">实战：构建客户端与服务端 pipeline</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ChannelInboundHandlerAdapter-与-ChannelOutboundHandlerAdapter"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">ChannelInboundHandlerAdapter 与 ChannelOutboundHandlerAdapter</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ByteToMessageDecoder"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">ByteToMessageDecoder</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#SimpleChannelInboundHandler"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">SimpleChannelInboundHandler</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#MessageToByteEncoder"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">MessageToByteEncoder</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#构建客户端与服务端-pipeline"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">构建客户端与服务端 pipeline</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#实战：拆包粘包理论与解决方案"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">实战：拆包粘包理论与解决方案</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#拆包粘包例子"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">拆包粘包例子</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么会有粘包半包现象？"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">为什么会有粘包半包现象？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#拆包的原理"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">拆包的原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Netty-自带的拆包器"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">Netty 自带的拆包器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何使用-LengthFieldBasedFrameDecoder"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">如何使用 LengthFieldBasedFrameDecoder</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#拒绝非本协议连接"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">拒绝非本协议连接</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#服务端和客户端的-pipeline-结构"><span class="toc_mobile_items-number">3.7.</span> <span class="toc_mobile_items-text">服务端和客户端的 pipeline 结构</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#channelHandler-的生命周期"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">channelHandler 的生命周期</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ChannelHandler-的生命周期详解"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">ChannelHandler 的生命周期详解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ChannelHandler-生命周期各回调方法用法举例"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">ChannelHandler 生命周期各回调方法用法举例</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#实战：使用-channelHandler-的热插拔实现客户端身份校验"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">实战：使用 channelHandler 的热插拔实现客户端身份校验</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1、身份校验"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">1、身份校验</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2、移除校验逻辑"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">2、移除校验逻辑</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3、-身份校验演示"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">3、 身份校验演示</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#pipeline-与-channelHandler"><span class="toc-number">1.</span> <span class="toc-text">pipeline 与 channelHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pipeline-与-channelHandler-的构成"><span class="toc-number">1.1.</span> <span class="toc-text">pipeline 与 channelHandler 的构成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#channelHandler-的分类"><span class="toc-number">1.2.</span> <span class="toc-text">channelHandler 的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChannelInboundHandler-的事件传播"><span class="toc-number">1.3.</span> <span class="toc-text">ChannelInboundHandler 的事件传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChannelOutboundHandler-的事件传播"><span class="toc-number">1.4.</span> <span class="toc-text">ChannelOutboundHandler 的事件传播</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实战：构建客户端与服务端-pipeline"><span class="toc-number">2.</span> <span class="toc-text">实战：构建客户端与服务端 pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ChannelInboundHandlerAdapter-与-ChannelOutboundHandlerAdapter"><span class="toc-number">2.1.</span> <span class="toc-text">ChannelInboundHandlerAdapter 与 ChannelOutboundHandlerAdapter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteToMessageDecoder"><span class="toc-number">2.2.</span> <span class="toc-text">ByteToMessageDecoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SimpleChannelInboundHandler"><span class="toc-number">2.3.</span> <span class="toc-text">SimpleChannelInboundHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MessageToByteEncoder"><span class="toc-number">2.4.</span> <span class="toc-text">MessageToByteEncoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建客户端与服务端-pipeline"><span class="toc-number">2.5.</span> <span class="toc-text">构建客户端与服务端 pipeline</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实战：拆包粘包理论与解决方案"><span class="toc-number">3.</span> <span class="toc-text">实战：拆包粘包理论与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#拆包粘包例子"><span class="toc-number">3.1.</span> <span class="toc-text">拆包粘包例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么会有粘包半包现象？"><span class="toc-number">3.2.</span> <span class="toc-text">为什么会有粘包半包现象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拆包的原理"><span class="toc-number">3.3.</span> <span class="toc-text">拆包的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-自带的拆包器"><span class="toc-number">3.4.</span> <span class="toc-text">Netty 自带的拆包器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何使用-LengthFieldBasedFrameDecoder"><span class="toc-number">3.5.</span> <span class="toc-text">如何使用 LengthFieldBasedFrameDecoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拒绝非本协议连接"><span class="toc-number">3.6.</span> <span class="toc-text">拒绝非本协议连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务端和客户端的-pipeline-结构"><span class="toc-number">3.7.</span> <span class="toc-text">服务端和客户端的 pipeline 结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#channelHandler-的生命周期"><span class="toc-number">4.</span> <span class="toc-text">channelHandler 的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ChannelHandler-的生命周期详解"><span class="toc-number">4.1.</span> <span class="toc-text">ChannelHandler 的生命周期详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChannelHandler-生命周期各回调方法用法举例"><span class="toc-number">4.2.</span> <span class="toc-text">ChannelHandler 生命周期各回调方法用法举例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实战：使用-channelHandler-的热插拔实现客户端身份校验"><span class="toc-number">5.</span> <span class="toc-text">实战：使用 channelHandler 的热插拔实现客户端身份校验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、身份校验"><span class="toc-number">5.1.</span> <span class="toc-text">1、身份校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、移除校验逻辑"><span class="toc-number">5.2.</span> <span class="toc-text">2、移除校验逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、-身份校验演示"><span class="toc-number">5.3.</span> <span class="toc-text">3、 身份校验演示</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/default_p5.jpeg)"><div id="post-info"><div id="post-title"><div class="posttitle">Netty项目-仿写微信 IM 即时通讯系统(2)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-07-28<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2019-11-28</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%BC%8F/">大数据分布式</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%BC%8F/socket%E7%BC%96%E7%A8%8B/">socket编程</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">3.4k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 12 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2019/07/28/20190728161454796/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2019/07/28/20190728161454796/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>目录</p>
<p>[TOC]</p>
<h1 id="pipeline-与-channelHandler"><a href="#pipeline-与-channelHandler" class="headerlink" title="pipeline 与 channelHandler"></a>pipeline 与 channelHandler</h1><p>问题：如何避免 <code>else</code> 泛滥？</p>
<p>一个大致处理流程：</p>
<p><a href="/2019/07/28/20190728161454796/16545510d7b4f970.jpeg" data-fancybox="group" data-caption="16545510d7b4f970" class="fancybox"><img alt="16545510d7b4f970" title="16545510d7b4f970" data-src="/2019/07/28/20190728161454796/16545510d7b4f970.jpeg" class="lazyload"></a> </p>
<p>缺陷：ClientHandler、ServerHandler类臃肿，每增加新命令都要添加分支。</p>
<p>解决：模块化处理，不同的逻辑放置到单独的类来处理，最后形成一个完整的逻辑处理链。</p>
<p>Netty 中的 pipeline 和 channelHandler 正是用来解决这个问题的：责任链设计模式</p>
<h2 id="pipeline-与-channelHandler-的构成"><a href="#pipeline-与-channelHandler-的构成" class="headerlink" title="pipeline 与 channelHandler 的构成"></a>pipeline 与 channelHandler 的构成</h2><p><a href="/2019/07/28/20190728161454796/1654526f0a67bb52.jpeg" data-fancybox="group" data-caption="1654526f0a67bb52" class="fancybox"><img alt="1654526f0a67bb52" title="1654526f0a67bb52" data-src="/2019/07/28/20190728161454796/1654526f0a67bb52.jpeg" class="lazyload"></a> </p>
<p>1、一条连接对应着一个 Channel，这条 Channel 所有的处理逻辑都在一个叫做 <code>ChannelPipeline</code> 的对象里面</p>
<p>2、<code>ChannelPipeline</code> 里面每个节点都是一个 <code>ChannelHandlerContext</code> 对象，这个对象能够拿到和 Channel 相关的所有的上下文信息，然后这个对象包着一个重要的对象，那就是逻辑处理器 <code>ChannelHandler</code>。</p>
<h2 id="channelHandler-的分类"><a href="#channelHandler-的分类" class="headerlink" title="channelHandler 的分类"></a>channelHandler 的分类</h2><p><a href="/2019/07/28/20190728161454796/1654526f0a8f2890.jpeg" data-fancybox="group" data-caption="1654526f0a8f2890" class="fancybox"><img alt="1654526f0a8f2890" title="1654526f0a8f2890" data-src="/2019/07/28/20190728161454796/1654526f0a8f2890.jpeg" class="lazyload"></a> </p>
<p> <code>ChannelHandler</code> 有两大子接口：</p>
<p>1、 <code>ChannelInboundHandler</code>，处理读数据的逻辑。我们在一端读到一段数据，要做解析、处理、响应， 在开始组装响应之前的所有的逻辑，都可以放置在 <code>ChannelInboundHandler</code> 里处理</p>
<p>2、 <code>ChannelOutBoundHandler</code> ，处理写数据的逻辑。它是定义我们一端在组装完响应之后，把数据写到对端的逻辑。比如，我们封装好一个 response 对象，接下来我们有可能对这个 response 做一些其他的特殊逻辑，然后，再编码成 ByteBuf，最终写到对端（response&gt;ByteBuf之间的一些公共操作）。 <code>write()</code>。</p>
<p>3、这两个子接口分别有对应的默认实现，<code>ChannelInboundHandlerAdapter</code>，和 <code>ChanneloutBoundHandlerAdapter</code>，它们分别实现了两大接口的所有功能，默认情况下会把读写事件传播到下一个 handler。</p>
<h2 id="ChannelInboundHandler-的事件传播"><a href="#ChannelInboundHandler-的事件传播" class="headerlink" title="ChannelInboundHandler 的事件传播"></a>ChannelInboundHandler 的事件传播</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerA());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerB());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerC());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></div>

<p>InBoundHandlerA</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InBoundHandlerA</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"InBoundHandlerA: "</span> + msg);</span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>1、父类的 channelRead() 方法会自动调用到下一个 inBoundHandler 的 channelRead() 方法，并且会把当前 inBoundHandler 里处理完毕的对象传递到下一个 inBoundHandler，例子中传递的对象都是同一个 msg</p>
<p>2、inBoundHandler 的执行顺序与我们通过 <code>addLast()</code> 方法 添加的顺序保持一致</p>
<h2 id="ChannelOutboundHandler-的事件传播"><a href="#ChannelOutboundHandler-的事件传播" class="headerlink" title="ChannelOutboundHandler 的事件传播"></a>ChannelOutboundHandler 的事件传播</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// outBound，处理写数据的逻辑链</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> OutBoundHandlerA());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> OutBoundHandlerB());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> OutBoundHandlerC());</span><br></pre></td></tr></table></figure></div>



<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutBoundHandlerA</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OutBoundHandlerA: "</span> + msg);</span><br><span class="line">        <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>1、父类的 <code>write()</code> 方法会自动调用到下一个 outBoundHandler 的 <code>write()</code> 方法，并且会把当前 outBoundHandler 里处理完毕的对象传递到下一个 outBoundHandler</p>
<p>2、可以看到，outBoundHandler 的执行顺序与我们添加的顺序相反</p>
<p>为什么？</p>
<blockquote>
<p>pipeline 的结构</p>
</blockquote>
<p><a href="/2019/07/28/20190728161454796/1654526f0a73d8c3.jpeg" data-fancybox="group" data-caption="1654526f0a73d8c3" class="fancybox"><img alt="1654526f0a73d8c3" title="1654526f0a73d8c3" data-src="/2019/07/28/20190728161454796/1654526f0a73d8c3.jpeg" class="lazyload"></a> </p>
<p>1、不管我们定义的是哪种类型的 handler, 最终它们都是以双向链表的方式连接,这里实际链表的节点是 <code>ChannelHandlerContext</code>。</p>
<p>2、虽然两种类型的 handler 在一个双向链表里，但是这两类 handler 的分工是不一样的。inBoundHandler 的事件通常只会传播到下一个 inBoundHandler，outBoundHandler 的事件通常只会传播到下一个 outBoundHandler，两者相互不受干扰。</p>
<p>在下一小节，我们会了解到几种特殊的 channelHandler，并且使用这几种特殊的 channelHandler 来改造我们的客户端和服务端逻辑，解决掉 <code>if else</code> 泛滥的问题。</p>
<h1 id="实战：构建客户端与服务端-pipeline"><a href="#实战：构建客户端与服务端-pipeline" class="headerlink" title="实战：构建客户端与服务端 pipeline"></a>实战：构建客户端与服务端 pipeline</h1><blockquote>
<p>把复杂的逻辑从单独的一个 channelHandler 中抽取出来。</p>
</blockquote>
<h2 id="ChannelInboundHandlerAdapter-与-ChannelOutboundHandlerAdapter"><a href="#ChannelInboundHandlerAdapter-与-ChannelOutboundHandlerAdapter" class="headerlink" title="ChannelInboundHandlerAdapter 与 ChannelOutboundHandlerAdapter"></a>ChannelInboundHandlerAdapter 与 ChannelOutboundHandlerAdapter</h2><blockquote>
<p>ChannelInboundHandlerAdapter.java</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>1、这里的 <code>msg</code> 就是上一个 handler 的输出</p>
<p>2、默认情况下 adapter 会通过 <code>fireChannelRead()</code> 方法直接把上一个 handler 的输出结果传递到下一个 handler。</p>
<blockquote>
<p> ChannelOutboundHandlerAdapter.java</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.write(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>我们往 pipeline 添加的第一个 handler 中的 <code>channelRead</code> 方法中，<code>msg</code> 对象其实就是 <code>ByteBuf</code>。</p>
<p>服务端在接受到数据之后，应该首先要做的第一步逻辑就是把这个 ByteBuf 进行解码，然后把解码后的结果传递到下一个 handler，如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf requestByteBuf = (ByteBuf) msg;</span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        Packet packet = PacketCodeC.INSTANCE.decode(requestByteBuf);</span><br><span class="line">        <span class="comment">// 解码后的对象传递到下一个 handler 处理</span></span><br><span class="line">        ctx.fireChannelRead(packet)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="ByteToMessageDecoder"><a href="#ByteToMessageDecoder" class="headerlink" title="ByteToMessageDecoder"></a>ByteToMessageDecoder</h2><p>把二进制数据转换到我们的一个 Java 对象</p>
<p>使用：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PacketDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List out)</span> </span>&#123;</span><br><span class="line">        out.add(PacketCodeC.INSTANCE.decode(in));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>1、我们通过往这个 <code>List</code> 里面添加解码后的结果对象，就可以自动实现结果往下一个 handler 进行传递</p>
<p>2、使用 <code>ByteToMessageDecoder</code>，Netty 会自动进行内存的释放，不用操心太多的内存管理方面的逻辑（ByteBuf是堆外内存需要自行释放）</p>
<h2 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h2><p>XXXHandler.java</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (packet <span class="keyword">instanceof</span> XXXPacket) &#123;</span><br><span class="line">    <span class="comment">// ...处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ctx.fireChannelRead(packet); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>SimpleChannelInboundHandler</code> 对象, 类型判断和对象传递的活都自动帮我们实现了，而我们可以专注于处理我们所关心的指令即可。</p>
<p>使用：</p>
<blockquote>
<p>LoginRequestHandler.java</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginRequestPacket</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestPacket loginRequestPacket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 登录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>MessageRequestHandler.java</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageRequestPacket</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageRequestPacket messageRequestPacket)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="MessageToByteEncoder"><a href="#MessageToByteEncoder" class="headerlink" title="MessageToByteEncoder"></a>MessageToByteEncoder</h2><p>写响应的时候处理逻辑类似，都需要进行编码，然后调用 <code>writeAndFlush()</code> 将数据写到客户端，这个编码的过程其实也是重复的逻辑。</p>
<p>而Netty 提供了一个特殊的 channelHandler 来专门处理编码逻辑，我们不需要每一次将响应写到对端的时候调用一次编码逻辑进行编码，也不需要自行创建 ByteBuf，这个类叫做 <code>MessageToByteEncoder</code></p>
<p>实现编码逻辑：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PacketEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Packet</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Packet packet, ByteBuf out)</span> </span>&#123;</span><br><span class="line">        PacketCodeC.INSTANCE.encode(out, packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>PacketCodeC.encode需要修改</p>
<h2 id="构建客户端与服务端-pipeline"><a href="#构建客户端与服务端-pipeline" class="headerlink" title="构建客户端与服务端 pipeline"></a>构建客户端与服务端 pipeline</h2><p><a href="/2019/07/28/20190728161454796/1666fd9cc2b9c089.jpeg" data-fancybox="group" data-caption="1666fd9cc2b9c089" class="fancybox"><img alt="1666fd9cc2b9c089" title="1666fd9cc2b9c089" data-src="/2019/07/28/20190728161454796/1666fd9cc2b9c089.jpeg" class="lazyload"></a> </p>
<blockquote>
<p>服务端</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">               .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> MessageRequestHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>客户端</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bootstrap</span><br><span class="line">        .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> LoginResponseHandler());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> MessageResponseHandler());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></div>



<h1 id="实战：拆包粘包理论与解决方案"><a href="#实战：拆包粘包理论与解决方案" class="headerlink" title="实战：拆包粘包理论与解决方案"></a>实战：拆包粘包理论与解决方案</h1><h2 id="拆包粘包例子"><a href="#拆包粘包例子" class="headerlink" title="拆包粘包例子"></a>拆包粘包例子</h2><p>客户端在连接建立成功之后，使用一个 for 循环，不断向服务端写一串数据。服务端收到数据之后，仅仅把数据打印出来。出现了服务端粘包半包现象。</p>
<blockquote>
<p>见 FirstClientHandler 、FirstServerHandler</p>
</blockquote>
<ol>
<li>一种是正常的字符串输出。</li>
<li>一种是多个字符串“粘”在了一起，我们定义这种 ByteBuf 为粘包。</li>
<li>一种是一个字符串被“拆”开，形成一个破碎的包，我们定义这种 ByteBuf 为半包。</li>
</ol>
<h2 id="为什么会有粘包半包现象？"><a href="#为什么会有粘包半包现象？" class="headerlink" title="为什么会有粘包半包现象？"></a>为什么会有粘包半包现象？</h2><ol>
<li><p>应用层是按照 ByteBuf 为 单位来发送数据，数据到了服务端，也是按照字节流的方式读入，然后到了 Netty 应用层面，重新拼装成 ByteBuf，而这里的 ByteBuf 与客户端按顺序发送的 ByteBuf 可能是不对等的。</p>
</li>
<li><p>因此，我们需要在客户端根据自定义协议来组装我们应用层的数据包，然后在服务端根据我们的应用层的协议来组装数据包，这个过程通常在服务端称为拆包，而在客户端称为粘包。</p>
</li>
<li><p>举个栗子，发送端将三个数据包粘成两个 TCP 数据包发送到接收端，接收端就需要根据应用协议将两个数据包重新组装成三个数据包。</p>
</li>
</ol>
<h2 id="拆包的原理"><a href="#拆包的原理" class="headerlink" title="拆包的原理"></a>拆包的原理</h2><p>用户如果自己需要拆包：略</p>
<h2 id="Netty-自带的拆包器"><a href="#Netty-自带的拆包器" class="headerlink" title="Netty 自带的拆包器"></a>Netty 自带的拆包器</h2><ol>
<li><p>固定长度的拆包器 FixedLengthFrameDecoder</p>
</li>
<li><p>行拆包器 LineBasedFrameDecoder</p>
</li>
<li><p>分隔符拆包器 DelimiterBasedFrameDecoder</p>
</li>
<li><p>基于长度域拆包器 LengthFieldBasedFrameDecoder</p>
<p>只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。</p>
</li>
</ol>
<h2 id="如何使用-LengthFieldBasedFrameDecoder"><a href="#如何使用-LengthFieldBasedFrameDecoder" class="headerlink" title="如何使用 LengthFieldBasedFrameDecoder"></a>如何使用 LengthFieldBasedFrameDecoder</h2><p>1、在自定义协议中，得到长度域偏移量和长度域的长度（7，4），构造一个拆包器。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">7</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></div>

<p>2、这样一个拆包器写好之后，只需要在 pipeline 的最前面加上这个拆包器。</p>
<blockquote>
<p>可参考的文章： <a href="https://www.jianshu.com/p/a0a51fd79f62" target="_blank" rel="noopener">netty源码分析之LengthFieldBasedFrameDecoder</a></p>
</blockquote>
<p>服务端</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">7</span>, <span class="number">4</span>));</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestHandler());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MessageRequestHandler());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br></pre></td></tr></table></figure></div>

<p>客户端</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">7</span>, <span class="number">4</span>));</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LoginResponseHandler());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MessageResponseHandler());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br></pre></td></tr></table></figure></div>

<p>这样，在后续 <code>PacketDecoder</code> 进行 decode 操作的时候，ByteBuf 就是一个完整的自定义协议数据包。</p>
<h2 id="拒绝非本协议连接"><a href="#拒绝非本协议连接" class="headerlink" title="拒绝非本协议连接"></a>拒绝非本协议连接</h2><blockquote>
<p>每个客户端发过来的数据包都做一次快速判断，判断当前发来的数据包是否是满足我的自定义协议， 我们只需要继承自 LengthFieldBasedFrameDecoder 的 <code>decode()</code> 方法，然后在 decode 之前判断前四个字节是否是等于我们定义的魔数 <code>0x12345678</code></p>
</blockquote>
<p>Spliter</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spliter</span> <span class="keyword">extends</span> <span class="title">LengthFieldBasedFrameDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_FIELD_OFFSET = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_FIELD_LENGTH = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spliter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Integer.MAX_VALUE, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 屏蔽非本协议的客户端</span></span><br><span class="line">        <span class="keyword">if</span> (in.getInt(in.readerIndex()) != PacketCodeC.MAGIC_NUMBER) &#123;</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.decode(ctx, in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实验一下:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ telnet 127.0.0.1 8000</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">telnet&gt;</span><span class="bash"> send ayt	<span class="comment"># 发送字符串“Are you There”</span></span></span><br><span class="line">Connection closed by foreign host. # 被关闭了</span><br></pre></td></tr></table></figure></div>

<p>向服务端发送一段字符串，由于这段字符串是不符合我们的自定义协议的，于是在第一时间，我们的服务端就关闭了这条连接。</p>
<h2 id="服务端和客户端的-pipeline-结构"><a href="#服务端和客户端的-pipeline-结构" class="headerlink" title="服务端和客户端的 pipeline 结构"></a>服务端和客户端的 pipeline 结构</h2><p>至此</p>
<p><a href="/2019/07/28/20190728161454796/1657e014321e00b0.jpeg" data-fancybox="group" data-caption="1657e014321e00b0" class="fancybox"><img alt="1657e014321e00b0" title="1657e014321e00b0" data-src="/2019/07/28/20190728161454796/1657e014321e00b0.jpeg" class="lazyload"></a> </p>
<h1 id="channelHandler-的生命周期"><a href="#channelHandler-的生命周期" class="headerlink" title="channelHandler 的生命周期"></a>channelHandler 的生命周期</h1><blockquote>
<p>回调方法的执行是有顺序的，而这个执行顺序可以称为 ChannelHandler 的生命周期</p>
</blockquote>
<h2 id="ChannelHandler-的生命周期详解"><a href="#ChannelHandler-的生命周期详解" class="headerlink" title="ChannelHandler 的生命周期详解"></a>ChannelHandler 的生命周期详解</h2><blockquote>
<p>ChannelInBoundHandler为例</p>
</blockquote>
<p>1、LifeCyCleTestHandler</p>
<p>运行 <code>NettyServer</code>，控制台输出：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">逻辑处理器被添加：handlerAdded()</span><br><span class="line">channel 绑定到线程(NioEventLoop)：channelRegistered()</span><br><span class="line">channel 准备就绪：channelActive()</span><br><span class="line">channel 有数据可读：channelRead()</span><br><span class="line">Thu Aug 01 21:12:46 CST 2019: 收到客户端登录请求……</span><br><span class="line">Thu Aug 01 21:12:46 CST 2019: 登录成功!</span><br><span class="line">channel 某次数据读完：channelReadComplete()</span><br><span class="line">channel 某次数据读完：channelReadComplete()</span><br><span class="line">channel 被关闭：channelInactive()</span><br><span class="line">channel 取消线程(NioEventLoop) 的绑定: channelUnregistered()</span><br><span class="line">逻辑处理器被移除：handlerRemoved()</span><br></pre></td></tr></table></figure></div>

<p>2、回调方法的执行顺序</p>
<p>3、每个回调方法的含义</p>
<p>略</p>
<p>4、一幅图来标识 ChannelHandler 的生命周期 </p>
<p><a href="/2019/07/28/20190728161454796/1666fdc2bdcf3f9e.jpeg" data-fancybox="group" data-caption="1666fdc2bdcf3f9e" class="fancybox"><img alt="1666fdc2bdcf3f9e" title="1666fdc2bdcf3f9e" data-src="/2019/07/28/20190728161454796/1666fdc2bdcf3f9e.jpeg" class="lazyload"></a> </p>
<h2 id="ChannelHandler-生命周期各回调方法用法举例"><a href="#ChannelHandler-生命周期各回调方法用法举例" class="headerlink" title="ChannelHandler 生命周期各回调方法用法举例"></a>ChannelHandler 生命周期各回调方法用法举例</h2><ol>
<li><p>ChannelInitializer 的实现原理</p>
<p>initChannel()方法是利用handlerAdded()启动的</p>
</li>
<li><p>handlerAdded() 与 handlerRemoved()</p>
<p>这两个方法通常可以用在一些资源的申请和释放</p>
</li>
<li><p>channelActive() 与 channelInActive()</p>
<ol>
<li>通常我们在这两个回调里面统计单机的连接数，<code>channelActive()</code> 被调用，连接数加一，<code>channelInActive()</code> 被调用，连接数减一</li>
<li>也可以在 <code>channelActive()</code> 方法中，实现对客户端连接 ip 黑白名单的过滤</li>
</ol>
</li>
<li><p>channelRead()</p>
<p>案例：拆包器，可参考阅读：<a href="https://www.jianshu.com/p/dc26e944da95" target="_blank" rel="noopener">netty源码分析之拆包器的奥秘</a></p>
</li>
<li><p>channelReadComplete()</p>
<p>在每次向客户端写数据的时候，都通过 <code>writeAndFlush()</code> 的方法写并刷新到底层，其实这种方式不是特别高效。</p>
<p>可以在之前调用 <code>writeAndFlush()</code> 的地方都换成 <code>write()</code> 方法，然后在这个方面里面调用 <code>ctx.channel().flush()</code> 方法，相当于一个批量刷新的机制</p>
<p>如果对性能要求没那么高，<code>writeAndFlush()</code> 足矣。</p>
</li>
</ol>
<h1 id="实战：使用-channelHandler-的热插拔实现客户端身份校验"><a href="#实战：使用-channelHandler-的热插拔实现客户端身份校验" class="headerlink" title="实战：使用 channelHandler 的热插拔实现客户端身份校验"></a>实战：使用 channelHandler 的热插拔实现客户端身份校验</h1><blockquote>
<ol>
<li>如果有很多业务逻辑的 handler 都要进行某些相同的操作，我们完全可以抽取出一个 handler 来单独处理</li>
<li>如果某一个独立的逻辑在执行几次之后（这里是一次）不需要再执行了，那么我们可以通过 ChannelHandler 的热插拔机制来实现动态删除逻辑，应用程序性能处理更为高效</li>
<li>很多操作在执行前都要进行登录校验，所以将其抽取为单独的handler；只要连接未断开，客户端只要成功登录过，后续就不需要每次都进行客户端的身份校验。</li>
</ol>
</blockquote>
<h2 id="1、身份校验"><a href="#1、身份校验" class="headerlink" title="1、身份校验"></a>1、身份校验</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --LoginRequestHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestPacket loginRequestPacket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (valid(loginRequestPacket)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 基于我们前面小节的代码，添加如下一行代码</span></span><br><span class="line">        LoginUtil.markAsLogin(ctx.channel());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --NettyServer.java</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestHandler());</span><br><span class="line"><span class="comment">// 新增加用户认证handler</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> AuthHandler());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MessageRequestHandler());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line"></span><br><span class="line"><span class="comment">// --AuthHandler.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!LoginUtil.hasLogin(ctx.channel())) &#123;</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2、移除校验逻辑"><a href="#2、移除校验逻辑" class="headerlink" title="2、移除校验逻辑"></a>2、移除校验逻辑</h2><blockquote>
<p>客户端只要成功登录过，后续就不需要再进行客户端的身份校验</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --AuthHandler.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!LoginUtil.hasLogin(ctx.channel())) &#123;</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一行代码实现逻辑的删除</span></span><br><span class="line">            ctx.pipeline().remove(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LoginUtil.hasLogin(ctx.channel())) &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前连接登录验证完毕，无需再次验证, AuthHandler 被移除"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"无登录验证，强制关闭连接!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="3、-身份校验演示"><a href="#3、-身份校验演示" class="headerlink" title="3、 身份校验演示"></a>3、 身份校验演示</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --NettyClient.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startConsoleThread</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">// 这里注释掉，因为已经有了校验handler</span></span><br><span class="line"><span class="comment">//                if (LoginUtil.hasLogin(channel)) &#123;</span></span><br><span class="line">                    System.out.println(<span class="string">"输入消息发送至服务端: "</span>);</span><br><span class="line">                    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                    String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line">                    channel.writeAndFlush(<span class="keyword">new</span> MessageRequestPacket(line));</span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>有身份认证的演示</p>
<p>无身份认证的演示：令用户名密码错误</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --LoginResponseHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"客户端连接被关闭!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>未完待续…</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Machine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://machine4869.gitee.io/2019/07/28/20190728161454796/">https://machine4869.gitee.io/2019/07/28/20190728161454796/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://machine4869.gitee.io">哑舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Netty/">Netty    </a></div><div class="post_share"><div class="social-share" data-image="/img/default_p5.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/08/09/20190809142144254/"><img class="prev_cover lazyload" data-src="/img/default_p11.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Netty项目-仿写微信 IM 即时通讯系统(3)</span></div></a></div><div class="next-post pull_right"><a href="/2019/07/22/20190722161728334/"><img class="next_cover lazyload" data-src="/img/default_p10.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Netty项目-仿写微信 IM 即时通讯系统(1)</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/08/13/20190813154158451/" title="用netty实现一个简单的rpc"><img class="relatedPosts_cover lazyload"data-src="/img/default_p12.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-08-13</div><div class="relatedPosts_title">用netty实现一个简单的rpc</div></div></a></div><div class="relatedPosts_item"><a href="/2019/08/09/20190809142144254/" title="Netty项目-仿写微信 IM 即时通讯系统(3)"><img class="relatedPosts_cover lazyload"data-src="/img/default_p11.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-08-09</div><div class="relatedPosts_title">Netty项目-仿写微信 IM 即时通讯系统(3)</div></div></a></div><div class="relatedPosts_item"><a href="/2019/07/22/20190722161728334/" title="Netty项目-仿写微信 IM 即时通讯系统(1)"><img class="relatedPosts_cover lazyload"data-src="/img/default_p10.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-22</div><div class="relatedPosts_title">Netty项目-仿写微信 IM 即时通讯系统(1)</div></div></a></div><div class="relatedPosts_item"><a href="/2019/07/22/20190722134143780/" title="Netty基础"><img class="relatedPosts_cover lazyload"data-src="/img/default_p5.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-22</div><div class="relatedPosts_title">Netty基础</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'yPVvDIaWlODDhs0bbECwLIIp-gzGzoHsz',
  appKey:'VyOIa40LxnjURzW1HUCiwTpV',
  placeholder:'记得留下你的昵称及邮箱，以便收到答复~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Machine</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://machine4869.gitee.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="215,215,215" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>