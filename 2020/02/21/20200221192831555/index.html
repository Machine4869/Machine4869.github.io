<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Java面试之JUC | 哑舍</title><meta name="description" content="Java面试之JUC"><meta name="keywords" content="Java面试笔试"><meta name="author" content="Machine"><meta name="copyright" content="Machine"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/cat2.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java面试之JUC"><meta name="twitter:description" content="Java面试之JUC"><meta name="twitter:image" content="https://machine4869.gitee.io/img/default_p12.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="Java面试之JUC"><meta property="og:url" content="https://machine4869.gitee.io/2020/02/21/20200221192831555/"><meta property="og:site_name" content="哑舍"><meta property="og:description" content="Java面试之JUC"><meta property="og:image" content="https://machine4869.gitee.io/img/default_p12.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://machine4869.gitee.io/2020/02/21/20200221192831555/"><link rel="next" title="JVM" href="https://machine4869.gitee.io/2020/02/15/20200215102406916/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://machine4869.gitee.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">哑舍</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 豆瓣电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片墙</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">134</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">45</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 豆瓣电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片墙</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Volatile"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Volatile</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#volatile是什么？为什么引入了volatile"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">volatile是什么？为什么引入了volatile</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#JMM抽象结构图描述"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">JMM抽象结构图描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#JMM如何保证同步的？"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">JMM如何保证同步的？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#JMM三大特性是什么？"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">JMM三大特性是什么？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#可见性是什么意思？"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">可见性是什么意思？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#volatile保证可见性代码演示"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">volatile保证可见性代码演示</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#原子性是什么意思？"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">原子性是什么意思？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#volatile不保证原子性代码演示"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">volatile不保证原子性代码演示</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#volatile不保证原子性理论解释（num-为什么不安全）"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">volatile不保证原子性理论解释（num++为什么不安全）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#volatile不保证原子性问题怎么解决？"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">volatile不保证原子性问题怎么解决？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#AtomicInteger保证原子性代码演示"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">AtomicInteger保证原子性代码演示</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#有序性之Happens-before原则"><span class="toc_mobile_items-number">1.12.</span> <span class="toc_mobile_items-text">* 有序性之Happens-before原则</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Volatile通过什么实现可见性？"><span class="toc_mobile_items-number">1.13.</span> <span class="toc_mobile_items-text">Volatile通过什么实现可见性？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是指令重排？造成什么问题？"><span class="toc_mobile_items-number">1.14.</span> <span class="toc_mobile_items-text">什么是指令重排？造成什么问题？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#指令重排造成的不安全举例"><span class="toc_mobile_items-number">1.15.</span> <span class="toc_mobile_items-text">* 指令重排造成的不安全举例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是内存屏障？"><span class="toc_mobile_items-number">1.16.</span> <span class="toc_mobile_items-text">* 什么是内存屏障？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何保证有序性？"><span class="toc_mobile_items-number">1.17.</span> <span class="toc_mobile_items-text">如何保证有序性？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#你在哪些地方用到了volatile"><span class="toc_mobile_items-number">1.18.</span> <span class="toc_mobile_items-text">你在哪些地方用到了volatile?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#单例模式在多线程下不安全代码演示"><span class="toc_mobile_items-number">1.19.</span> <span class="toc_mobile_items-text">单例模式在多线程下不安全代码演示</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#单例模式在多线程下不安全解决方案？"><span class="toc_mobile_items-number">1.20.</span> <span class="toc_mobile_items-text">! 单例模式在多线程下不安全解决方案？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么只用DCL不能保证线程安全？"><span class="toc_mobile_items-number">1.21.</span> <span class="toc_mobile_items-text">为什么只用DCL不能保证线程安全？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#CAS"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">CAS</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#compareAndSet怎么用？"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">compareAndSet怎么用？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CAS底层原理简述？"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">CAS底层原理简述？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#getAndIncrement-源码解析（用了cas保证线程安全）"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">getAndIncrement() 源码解析（用了cas保证线程安全）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#对Unsafe的理解"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">对Unsafe的理解?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CAS有哪些缺点？"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">! CAS有哪些缺点？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ABA问题"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">ABA问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#简述ABA问题和解决方案？"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">简述ABA问题和解决方案？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ABA问题描述？问题出在哪？"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">ABA问题描述？问题出在哪？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#原子更新引用是啥？"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">原子更新引用是啥？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#AtomicReference使用代码演示"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">AtomicReference使用代码演示</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#AtomicReference存在ABA问题代码验证"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">AtomicReference存在ABA问题代码验证</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#AtomicStampReference解决ABA问题代码验证"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">AtomicStampReference解决ABA问题代码验证</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#集合类不安全"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">集合类不安全</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ArrayList线程不安全演示-什么故障？什么原因？怎么解决？"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">ArrayList线程不安全演示-什么故障？什么原因？怎么解决？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CopyOnWriteArrayList原理？它有什么好？"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">CopyOnWriteArrayList原理？它有什么好？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CopyOnWriteArrayList-缺点-amp-使用场合"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">CopyOnWriteArrayList 缺点&amp;使用场合</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CopyOnWriteArrayList透露的思想"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">CopyOnWriteArrayList透露的思想</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#集合类不安全之Set-演示-故障-解决"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">集合类不安全之Set-演示&#x2F;故障&#x2F;解决</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#集合类不安全之Map-演示-故障-解决"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">集合类不安全之Map-演示&#x2F;故障&#x2F;解决</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#HashMap底层实现原理-jdk7"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">HashMap底层实现原理-jdk7</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ConcurrentHashMap底层原理-jdk7"><span class="toc_mobile_items-number">4.8.</span> <span class="toc_mobile_items-text">ConcurrentHashMap底层原理-jdk7</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#HashMap底层实现原理-jdk8"><span class="toc_mobile_items-number">4.9.</span> <span class="toc_mobile_items-text">HashMap底层实现原理-jdk8</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ConcurrentHashMap底层原理-jdk8"><span class="toc_mobile_items-number">4.10.</span> <span class="toc_mobile_items-text">! ConcurrentHashMap底层原理-jdk8</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Map类的各种对比"><span class="toc_mobile_items-number">4.11.</span> <span class="toc_mobile_items-text">Map类的各种对比</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java锁"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Java锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java-15锁，列举一些？"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">Java 15锁，列举一些？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#公平和非公平锁是什么？两者区别（优缺点）？两种锁举例？"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">公平和非公平锁是什么？两者区别（优缺点）？两种锁举例？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#可重入锁是什么？与不可重入的区别？可重入锁举例？作用？实现原理？"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">可重入锁是什么？与不可重入的区别？可重入锁举例？作用？实现原理？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#可重入锁代码验证"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">可重入锁代码验证</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#自旋锁是什么？优点？缺点？"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text">自旋锁是什么？优点？缺点？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#手写一个自旋锁"><span class="toc_mobile_items-number">5.6.</span> <span class="toc_mobile_items-text">手写一个自旋锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#独占锁和共享锁是什么？举例？优缺点比较？"><span class="toc_mobile_items-number">5.7.</span> <span class="toc_mobile_items-text">独占锁和共享锁是什么？举例？优缺点比较？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#验证读写锁ReentrantReadWriteLock"><span class="toc_mobile_items-number">5.8.</span> <span class="toc_mobile_items-text">验证读写锁ReentrantReadWriteLock</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是乐观锁-悲观锁？举例？"><span class="toc_mobile_items-number">5.9.</span> <span class="toc_mobile_items-text">什么是乐观锁&#x2F;悲观锁？举例？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是乐观读-悲观读？"><span class="toc_mobile_items-number">5.10.</span> <span class="toc_mobile_items-text">什么是乐观读&#x2F;悲观读？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ReentrantReadWriteLock是乐观读还是悲观读？"><span class="toc_mobile_items-number">5.11.</span> <span class="toc_mobile_items-text">ReentrantReadWriteLock是乐观读还是悲观读？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#StempedLock作用？"><span class="toc_mobile_items-number">5.12.</span> <span class="toc_mobile_items-text">StempedLock作用？</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Volatile"><span class="toc-number">1.</span> <span class="toc-text">Volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile是什么？为什么引入了volatile"><span class="toc-number">1.1.</span> <span class="toc-text">volatile是什么？为什么引入了volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM抽象结构图描述"><span class="toc-number">1.2.</span> <span class="toc-text">JMM抽象结构图描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM如何保证同步的？"><span class="toc-number">1.3.</span> <span class="toc-text">JMM如何保证同步的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM三大特性是什么？"><span class="toc-number">1.4.</span> <span class="toc-text">JMM三大特性是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可见性是什么意思？"><span class="toc-number">1.5.</span> <span class="toc-text">可见性是什么意思？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile保证可见性代码演示"><span class="toc-number">1.6.</span> <span class="toc-text">volatile保证可见性代码演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原子性是什么意思？"><span class="toc-number">1.7.</span> <span class="toc-text">原子性是什么意思？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile不保证原子性代码演示"><span class="toc-number">1.8.</span> <span class="toc-text">volatile不保证原子性代码演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile不保证原子性理论解释（num-为什么不安全）"><span class="toc-number">1.9.</span> <span class="toc-text">volatile不保证原子性理论解释（num++为什么不安全）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile不保证原子性问题怎么解决？"><span class="toc-number">1.10.</span> <span class="toc-text">volatile不保证原子性问题怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AtomicInteger保证原子性代码演示"><span class="toc-number">1.11.</span> <span class="toc-text">AtomicInteger保证原子性代码演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有序性之Happens-before原则"><span class="toc-number">1.12.</span> <span class="toc-text">* 有序性之Happens-before原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatile通过什么实现可见性？"><span class="toc-number">1.13.</span> <span class="toc-text">Volatile通过什么实现可见性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是指令重排？造成什么问题？"><span class="toc-number">1.14.</span> <span class="toc-text">什么是指令重排？造成什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指令重排造成的不安全举例"><span class="toc-number">1.15.</span> <span class="toc-text">* 指令重排造成的不安全举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是内存屏障？"><span class="toc-number">1.16.</span> <span class="toc-text">* 什么是内存屏障？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何保证有序性？"><span class="toc-number">1.17.</span> <span class="toc-text">如何保证有序性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#你在哪些地方用到了volatile"><span class="toc-number">1.18.</span> <span class="toc-text">你在哪些地方用到了volatile?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式在多线程下不安全代码演示"><span class="toc-number">1.19.</span> <span class="toc-text">单例模式在多线程下不安全代码演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式在多线程下不安全解决方案？"><span class="toc-number">1.20.</span> <span class="toc-text">! 单例模式在多线程下不安全解决方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么只用DCL不能保证线程安全？"><span class="toc-number">1.21.</span> <span class="toc-text">为什么只用DCL不能保证线程安全？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS"><span class="toc-number">2.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#compareAndSet怎么用？"><span class="toc-number">2.1.</span> <span class="toc-text">compareAndSet怎么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS底层原理简述？"><span class="toc-number">2.2.</span> <span class="toc-text">CAS底层原理简述？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getAndIncrement-源码解析（用了cas保证线程安全）"><span class="toc-number">2.3.</span> <span class="toc-text">getAndIncrement() 源码解析（用了cas保证线程安全）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对Unsafe的理解"><span class="toc-number">2.4.</span> <span class="toc-text">对Unsafe的理解?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS有哪些缺点？"><span class="toc-number">2.5.</span> <span class="toc-text">! CAS有哪些缺点？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ABA问题"><span class="toc-number">3.</span> <span class="toc-text">ABA问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简述ABA问题和解决方案？"><span class="toc-number">3.1.</span> <span class="toc-text">简述ABA问题和解决方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ABA问题描述？问题出在哪？"><span class="toc-number">3.2.</span> <span class="toc-text">ABA问题描述？问题出在哪？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原子更新引用是啥？"><span class="toc-number">3.3.</span> <span class="toc-text">原子更新引用是啥？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AtomicReference使用代码演示"><span class="toc-number">3.4.</span> <span class="toc-text">AtomicReference使用代码演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AtomicReference存在ABA问题代码验证"><span class="toc-number">3.5.</span> <span class="toc-text">AtomicReference存在ABA问题代码验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AtomicStampReference解决ABA问题代码验证"><span class="toc-number">3.6.</span> <span class="toc-text">AtomicStampReference解决ABA问题代码验证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合类不安全"><span class="toc-number">4.</span> <span class="toc-text">集合类不安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList线程不安全演示-什么故障？什么原因？怎么解决？"><span class="toc-number">4.1.</span> <span class="toc-text">ArrayList线程不安全演示-什么故障？什么原因？怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList原理？它有什么好？"><span class="toc-number">4.2.</span> <span class="toc-text">CopyOnWriteArrayList原理？它有什么好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList-缺点-amp-使用场合"><span class="toc-number">4.3.</span> <span class="toc-text">CopyOnWriteArrayList 缺点&amp;使用场合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList透露的思想"><span class="toc-number">4.4.</span> <span class="toc-text">CopyOnWriteArrayList透露的思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合类不安全之Set-演示-故障-解决"><span class="toc-number">4.5.</span> <span class="toc-text">集合类不安全之Set-演示&#x2F;故障&#x2F;解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合类不安全之Map-演示-故障-解决"><span class="toc-number">4.6.</span> <span class="toc-text">集合类不安全之Map-演示&#x2F;故障&#x2F;解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap底层实现原理-jdk7"><span class="toc-number">4.7.</span> <span class="toc-text">HashMap底层实现原理-jdk7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap底层原理-jdk7"><span class="toc-number">4.8.</span> <span class="toc-text">ConcurrentHashMap底层原理-jdk7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap底层实现原理-jdk8"><span class="toc-number">4.9.</span> <span class="toc-text">HashMap底层实现原理-jdk8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap底层原理-jdk8"><span class="toc-number">4.10.</span> <span class="toc-text">! ConcurrentHashMap底层原理-jdk8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map类的各种对比"><span class="toc-number">4.11.</span> <span class="toc-text">Map类的各种对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java锁"><span class="toc-number">5.</span> <span class="toc-text">Java锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-15锁，列举一些？"><span class="toc-number">5.1.</span> <span class="toc-text">Java 15锁，列举一些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#公平和非公平锁是什么？两者区别（优缺点）？两种锁举例？"><span class="toc-number">5.2.</span> <span class="toc-text">公平和非公平锁是什么？两者区别（优缺点）？两种锁举例？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可重入锁是什么？与不可重入的区别？可重入锁举例？作用？实现原理？"><span class="toc-number">5.3.</span> <span class="toc-text">可重入锁是什么？与不可重入的区别？可重入锁举例？作用？实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可重入锁代码验证"><span class="toc-number">5.4.</span> <span class="toc-text">可重入锁代码验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自旋锁是什么？优点？缺点？"><span class="toc-number">5.5.</span> <span class="toc-text">自旋锁是什么？优点？缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#手写一个自旋锁"><span class="toc-number">5.6.</span> <span class="toc-text">手写一个自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#独占锁和共享锁是什么？举例？优缺点比较？"><span class="toc-number">5.7.</span> <span class="toc-text">独占锁和共享锁是什么？举例？优缺点比较？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#验证读写锁ReentrantReadWriteLock"><span class="toc-number">5.8.</span> <span class="toc-text">验证读写锁ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是乐观锁-悲观锁？举例？"><span class="toc-number">5.9.</span> <span class="toc-text">什么是乐观锁&#x2F;悲观锁？举例？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是乐观读-悲观读？"><span class="toc-number">5.10.</span> <span class="toc-text">什么是乐观读&#x2F;悲观读？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock是乐观读还是悲观读？"><span class="toc-number">5.11.</span> <span class="toc-text">ReentrantReadWriteLock是乐观读还是悲观读？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StempedLock作用？"><span class="toc-number">5.12.</span> <span class="toc-text">StempedLock作用？</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/default_p12.jpeg)"><div id="post-info"><div id="post-title"><div class="posttitle">Java面试之JUC</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-02-21<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-02-23</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/">Java面试笔试</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.6k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 30 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2020/02/21/20200221192831555/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/02/21/20200221192831555/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><h2 id="volatile是什么？为什么引入了volatile"><a href="#volatile是什么？为什么引入了volatile" class="headerlink" title="volatile是什么？为什么引入了volatile"></a>volatile是什么？为什么引入了volatile</h2><p>volatile是java虚拟机提供的一种轻量级同步机制</p>
<ol>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排（保证了有序性）</li>
</ol>
<p>高并发下不用synchronized，因为并发性不好；用volatile和juc下面的类；</p>
<h2 id="JMM抽象结构图描述"><a href="#JMM抽象结构图描述" class="headerlink" title="JMM抽象结构图描述"></a>JMM抽象结构图描述</h2><p>关于JMM: blog/2018/07/27/15326929363424/#2-3-JAVA内存模型（JMM）</p>
<p>结构图主要描述：</p>
<ul>
<li>主内存/工作内存/共享变量/拷贝副本</li>
<li>JMM是一种抽象概念，不真实存在，它描述的是一组规则/规范</li>
</ul>
<h2 id="JMM如何保证同步的？"><a href="#JMM如何保证同步的？" class="headerlink" title="JMM如何保证同步的？"></a>JMM如何保证同步的？</h2><ol>
<li>解锁前，把工作内存的值刷到主内存</li>
<li>加锁时，从主内存读取最新值到工作内存</li>
<li>加锁解锁是同一把锁</li>
</ol>
<h2 id="JMM三大特性是什么？"><a href="#JMM三大特性是什么？" class="headerlink" title="JMM三大特性是什么？"></a>JMM三大特性是什么？</h2><ol>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ol>
<p>三大特性使线程安全性获得保证</p>
<h2 id="可见性是什么意思？"><a href="#可见性是什么意思？" class="headerlink" title="可见性是什么意思？"></a>可见性是什么意思？</h2><p>某线程如果修改了主内存的共享变量，对其他线程是可见的。</p>
<h2 id="volatile保证可见性代码演示"><a href="#volatile保证可见性代码演示" class="headerlink" title="volatile保证可见性代码演示"></a>volatile保证可见性代码演示</h2><p>demo</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mxx.juc;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可见性验证：</span></span><br><span class="line"><span class="comment">* - a线程修改变量值</span></span><br><span class="line"><span class="comment">* - 对b线程（main）是否可见</span></span><br><span class="line"><span class="comment">* 结论：</span></span><br><span class="line"><span class="comment">* - 不加volatile，a线程的修改对b线程不可见</span></span><br><span class="line"><span class="comment">* - 加volatile，a线程的修改对b线程可见</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// int num = 1;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeNum</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.num = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线程 操作 资源类</span></span><br><span class="line">VolatileDemo vd = <span class="keyword">new</span> VolatileDemo();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">"进入线程"</span>+Thread.currentThread().getName()+<span class="string">"，num="</span>+vd.num);</span><br><span class="line"><span class="comment">// 休息，等待num被其他线程读取到</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">vd.changeNum();</span><br><span class="line">System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"修改num，num="</span>+vd.num);</span><br><span class="line">&#125;,<span class="string">"a"</span>).start();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (vd.num==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">// 一直等待循环</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"线程结束，num="</span>+vd.num);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加volatile:</span></span><br><span class="line"><span class="comment">//进入线程a，num=1</span></span><br><span class="line"><span class="comment">//线程a修改num，num=30</span></span><br><span class="line"><span class="comment">//main线程结束，num=30</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="原子性是什么意思？"><a href="#原子性是什么意思？" class="headerlink" title="原子性是什么意思？"></a>原子性是什么意思？</h2><p>某个线程在做具体业务时，要么整体成功，要么整体失败，保证数据一致性</p>
<h2 id="volatile不保证原子性代码演示"><a href="#volatile不保证原子性代码演示" class="headerlink" title="volatile不保证原子性代码演示"></a>volatile不保证原子性代码演示</h2><p>demo</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mxx.juc;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int num = 1;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 不保证原子性验证：</span></span><br><span class="line"><span class="comment">   * - 20个线程，每个线程1000次，做+1操作</span></span><br><span class="line"><span class="comment">   * - 20个线程全部跑完后，看main函数打印结果</span></span><br><span class="line"><span class="comment">   * 结论：</span></span><br><span class="line"><span class="comment">   * - 每次结果都不一样，小于20001</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    VolatileDemo vd = <span class="keyword">new</span> VolatileDemo();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">          vd.addNum();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,<span class="string">"线程"</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主线程+GC线程</span></span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="comment">// 线程礼让</span></span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"线程: num="</span>+ vd.num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="volatile不保证原子性理论解释（num-为什么不安全）"><a href="#volatile不保证原子性理论解释（num-为什么不安全）" class="headerlink" title="volatile不保证原子性理论解释（num++为什么不安全）"></a>volatile不保证原子性理论解释（num++为什么不安全）</h2><p>num++出现问题底层逻辑（javap -c）：</p>
<ol>
<li>获得：各线程从主内存读num到工作内存</li>
<li>修改：各线程在各自工作内存做+1操作，工作内存中的操作互相不可见。</li>
<li>写回：线程在写回前被挂起了，写回的时候<strong>相互覆盖</strong>，造成数值丢失。</li>
</ol>
<h2 id="volatile不保证原子性问题怎么解决？"><a href="#volatile不保证原子性问题怎么解决？" class="headerlink" title="volatile不保证原子性问题怎么解决？"></a>volatile不保证原子性问题怎么解决？</h2><ol>
<li>加synchronized，并发性能不好</li>
<li>juc的atomic，比如AtomicInteger的getAndIncrement()</li>
</ol>
<h2 id="AtomicInteger保证原子性代码演示"><a href="#AtomicInteger保证原子性代码演示" class="headerlink" title="AtomicInteger保证原子性代码演示"></a>AtomicInteger保证原子性代码演示</h2><p>demo</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger num2 = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNumByAtomic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num2.getAndIncrement();</span><br><span class="line">     <span class="comment">// num2.incrementAndGet();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile不保证原子性解决：</span></span><br><span class="line"><span class="comment"> * - AtomicInteger</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// seeOkByVolatile();</span></span><br><span class="line">  VolatileDemo vd = <span class="keyword">new</span> VolatileDemo();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 不安全</span></span><br><span class="line">        vd.addNum();</span><br><span class="line">        <span class="comment">// 安全</span></span><br><span class="line">        vd.addNumByAtomic();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">"线程"</span>+i).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主线程+GC线程</span></span><br><span class="line">  <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 线程礼让</span></span><br><span class="line">    Thread.yield();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(Thread.currentThread().getName()+<span class="string">"线程: num="</span>+ vd.num);</span><br><span class="line">  System.out.println(Thread.currentThread().getName()+<span class="string">"线程: num2="</span>+ vd.num2);</span><br><span class="line">  <span class="comment">// main线程: num=13808</span></span><br><span class="line">  <span class="comment">// main线程: num2=20001</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="有序性之Happens-before原则"><a href="#有序性之Happens-before原则" class="headerlink" title="* 有序性之Happens-before原则"></a>* 有序性之Happens-before原则</h2><p>java内存模型一个列出了八种Happens-before规则，如果两个操作的次序不能从这八种规则中推倒出来，则不能保证有序性</p>
<p>更详细的：blog/2018/07/28/15327607157902/#4-4-有序性</p>
<h2 id="Volatile通过什么实现可见性？"><a href="#Volatile通过什么实现可见性？" class="headerlink" title="Volatile通过什么实现可见性？"></a>Volatile通过什么实现可见性？</h2><p>通过加入 <strong>内存屏障</strong> 和 <strong>禁止重排序优化</strong>来实现</p>
<h2 id="什么是指令重排？造成什么问题？"><a href="#什么是指令重排？造成什么问题？" class="headerlink" title="什么是指令重排？造成什么问题？"></a>什么是指令重排？造成什么问题？</h2><ol>
<li>Java内存模型中，为提高性能，允许编译器和处理器对指令进行重排序。</li>
<li>重排时会考虑到指令间的数据依赖性</li>
<li>不会影响单线程环境下程序执行</li>
<li>多线程下，线程交替执行，由于优化重排的存在，两线程使用的变量能否保证一致性是无法确定的。结果无法预测。</li>
</ol>
<h2 id="指令重排造成的不安全举例"><a href="#指令重排造成的不安全举例" class="headerlink" title="* 指令重排造成的不安全举例"></a>* 指令重排造成的不安全举例</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a=<span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">  flag=<span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    a = a+<span class="number">5</span>; <span class="comment">// 3</span></span><br><span class="line">    System.out.println(<span class="string">"revalue="</span>+a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>解释：</p>
<ol>
<li>线程1执行m1，线程2执行m2</li>
<li>在不重排时，一定是按照123步骤执行，结果为6</li>
<li>如果发生重排，比如1和2交换了顺序，当m1执行完2时，线程切换，执行m1，这时可以进入if函数，a结果为5 </li>
</ol>
<h2 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="* 什么是内存屏障？"></a>* 什么是内存屏障？</h2><p>详细：blog/2018/07/28/15327607157902/#4-3-可见性</p>
<p>关键字：</p>
<ul>
<li>load屏障/store屏障</li>
<li>volatile读/volatile写</li>
<li>内存屏障还能强制刷出cpu缓存，保证数据最新</li>
</ul>
<h2 id="如何保证有序性？"><a href="#如何保证有序性？" class="headerlink" title="如何保证有序性？"></a>如何保证有序性？</h2><p>保证有序性：volatile、synchronized、Lock</p>
<h2 id="你在哪些地方用到了volatile"><a href="#你在哪些地方用到了volatile" class="headerlink" title="你在哪些地方用到了volatile?"></a>你在哪些地方用到了volatile?</h2><ol>
<li>单例模式在多线程下不安全</li>
<li>读写锁/手写缓存</li>
<li>cas底层源码分析</li>
</ol>
<h2 id="单例模式在多线程下不安全代码演示"><a href="#单例模式在多线程下不安全代码演示" class="headerlink" title="单例模式在多线程下不安全代码演示"></a>单例模式在多线程下不安全代码演示</h2><p>demo</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"\t调用构造方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单线程下，单例模式正常。</span></span><br><span class="line"><span class="comment">//    System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span><br><span class="line"><span class="comment">//    System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span><br><span class="line"><span class="comment">//    System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span><br><span class="line">    <span class="comment">//main 调用构造方法</span></span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多线程下，单例模式不行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        SingletonDemo.getInstance();</span><br><span class="line">      &#125;,<span class="string">"线程"</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程0 调用构造方法</span></span><br><span class="line">    <span class="comment">//线程4 调用构造方法</span></span><br><span class="line">    <span class="comment">//线程3 调用构造方法</span></span><br><span class="line">    <span class="comment">//线程2 调用构造方法</span></span><br><span class="line">    <span class="comment">//线程1 调用构造方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="单例模式在多线程下不安全解决方案？"><a href="#单例模式在多线程下不安全解决方案？" class="headerlink" title="! 单例模式在多线程下不安全解决方案？"></a>! 单例模式在多线程下不安全解决方案？</h2><p>DCL双端检索机制+volatile</p>
<h2 id="为什么只用DCL不能保证线程安全？"><a href="#为什么只用DCL不能保证线程安全？" class="headerlink" title="为什么只用DCL不能保证线程安全？"></a>为什么只用DCL不能保证线程安全？</h2><p>简答：在创建对象过程中发生指令重排。检测到intance不为null但对象却没有完全创建成功。</p>
<p>双端检索机制：在加锁前和加锁后都进行一次判断</p>
<p>demo:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为什么以上代码不一定安全？</p>
<ol>
<li>因为有指令重排序的存在</li>
<li>原因在于：某线程读到instance不为nul时，instance的引用对象可能还没有完成初始化（new SingletonDemo()做到一半）<br>instance = new SingletonDemo()分为以下步骤：<br>1）分配对象内存空间<br>2）初始化对象<br>3）设置instance指向内存地址，此时instance != nul<br>其中步骤2 3可能发生重排，</li>
<li>因此多线程下，当线程a访问instance!=null时，instance实例却未必初始化完成（还没做2）；此时切到线程b，线程b直接取intance实例，这个实例是未完成初始化的实例。因此线程不安全。</li>
</ol>
<p>如何解决？</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 告诉编译器禁止指令重排</span></span><br></pre></td></tr></table></figure></div>



<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>提问线路：CAS—&gt; Unsafe—&gt; CAS底层原理 —&gt; 原子引用更新 —&gt; 如何规避ABA问题</p>
<h2 id="compareAndSet怎么用？"><a href="#compareAndSet怎么用？" class="headerlink" title="compareAndSet怎么用？"></a>compareAndSet怎么用？</h2><p>比较并交换（compareAndSet）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * boolean compareAndSet(int expect, int update)</span></span><br><span class="line"><span class="comment"> * - 如果主内存的值=期待值expect，就将主内存值改为update</span></span><br><span class="line"><span class="comment"> * - 该方法可以检测线程a的操作变量X没有被其他线程修改过</span></span><br><span class="line"><span class="comment"> * - 保证了线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">    System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">10</span>)+ <span class="string">"\t"</span> + atomicInteger);</span><br><span class="line">    System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">20</span>)+ <span class="string">"\t"</span> + atomicInteger);</span><br><span class="line">    <span class="comment">//true	10</span></span><br><span class="line">    <span class="comment">//false	10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="CAS底层原理简述？"><a href="#CAS底层原理简述？" class="headerlink" title="CAS底层原理简述？"></a>CAS底层原理简述？</h2><ol>
<li>Compare-And-Swap。是一条CPU并发原语。（原语：操作系统范畴，依赖硬件，不被中断。）</li>
<li>功能是判断内存某个位置的值是否为预期值（Compare），是就更新（Swap），这个过程是原子的。</li>
<li>功能描述：<ol>
<li>判断内存某个位置的值是否为预期值（Compare），是就更新（Swap），这个过程是原子的。</li>
<li>cas有三个操作数，内存值V，旧预期值A，要更新的值B。仅当预期值A=内存值V时，才将内存值V修改为B，否则什么都不做。</li>
</ol>
</li>
<li>自旋：比较并交换，直到比较成功</li>
<li>底层靠Unsafe类保证原子性。</li>
</ol>
<h2 id="getAndIncrement-源码解析（用了cas保证线程安全）"><a href="#getAndIncrement-源码解析（用了cas保证线程安全）" class="headerlink" title="getAndIncrement() 源码解析（用了cas保证线程安全）"></a>getAndIncrement() 源码解析（用了cas保证线程安全）</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> * this: atomicInteger对象</span></span><br><span class="line"><span class="comment"> * valueOffset：对象的内存地址</span></span><br><span class="line"><span class="comment"> * unsafe：sun.misc.Unsafe类</span></span><br><span class="line"><span class="comment"> * AtomicInteger中变量value使用volatile修饰，保证内存可见。</span></span><br><span class="line"><span class="comment"> * 结论：底层依赖CAS操作/Unsafe类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * compareAndSwapInt：即CAS</span></span><br><span class="line"><span class="comment"> * while: 如果修改失败，会一直尝试修改，直到成功。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简述：</p>
<ol>
<li>调用了Unsafe类的getAndAddInt</li>
<li>getAndAddInt使用cas一直循环尝试修改主内存</li>
</ol>
<h2 id="对Unsafe的理解"><a href="#对Unsafe的理解" class="headerlink" title="对Unsafe的理解?"></a>对Unsafe的理解?</h2><p>Unsave类</p>
<ol>
<li>该类所有方法都是native修饰，直接调用底层资源。sun.misc包中。</li>
<li>可以像C的指针一样直接操作内存。java的CAS操作依赖Unsafe类的方法。</li>
</ol>
<h2 id="CAS有哪些缺点？"><a href="#CAS有哪些缺点？" class="headerlink" title="! CAS有哪些缺点？"></a>! CAS有哪些缺点？</h2><ol>
<li>循环时间长，开销大<ol>
<li>如果cas失败，就一直do while尝试。如果长时间不成功，可能给CPU带来很大开销。</li>
</ol>
</li>
<li>只能保证一个共享变量的原子操作<ol>
<li>如果时多个共享变量，cas无法保证原子性，只能加锁，锁住代码段。</li>
</ol>
</li>
<li>引出来ABA问题。</li>
</ol>
<h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><h2 id="简述ABA问题和解决方案？"><a href="#简述ABA问题和解决方案？" class="headerlink" title="简述ABA问题和解决方案？"></a>简述ABA问题和解决方案？</h2><p>简述版：</p>
<p>ABA问题描述: 线程1做CAS操作将A改为B再改为A，而线程2再做CAS时修改成功了，这不符合设计思想。</p>
<p>怎么解决：AtomicStampReference时间戳原子引用</p>
<h2 id="ABA问题描述？问题出在哪？"><a href="#ABA问题描述？问题出在哪？" class="headerlink" title="ABA问题描述？问题出在哪？"></a>ABA问题描述？问题出在哪？</h2><p>ABA问题描述：</p>
<ul>
<li>比如线程1从内存位置V中取出A，此时线程2也取出A。且线程2做了一次cas将值改为了B，然后又做了一次cas将值改回了A。此时线程1做cas发现内存中还是A，则线程1操作成功。这个时候实际上A值已经被其他线程改变过，这与设计思想是不符合的。</li>
</ul>
<p>这个过程问题出在哪？</p>
<ul>
<li>如果只在乎结果，ABA不介意B的存在，没什么问题</li>
<li>如果B的存在会造成影响，需要通过AtomicStampReference，加时间戳解决。</li>
</ul>
<h2 id="原子更新引用是啥？"><a href="#原子更新引用是啥？" class="headerlink" title="原子更新引用是啥？"></a>原子更新引用是啥？</h2><p>AtomicStampReference，使用时间戳，解决cas中出现的ABA问题。</p>
<h2 id="AtomicReference使用代码演示"><a href="#AtomicReference使用代码演示" class="headerlink" title="AtomicReference使用代码演示"></a>AtomicReference使用代码演示</h2><p>demo</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果希望原子操作的变量是User,Book,此时需要使用AtomicReference类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User z3 = <span class="keyword">new</span> User(<span class="string">"z3"</span>,<span class="number">18</span>);</span><br><span class="line">    User l4 = <span class="keyword">new</span> User(<span class="string">"l4"</span>,<span class="number">19</span>);</span><br><span class="line">    AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(z3);</span><br><span class="line">    System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">"\t"</span> + atomicReference.get().toString());</span><br><span class="line">    System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">"\t"</span> + atomicReference.get().toString());</span><br><span class="line">    <span class="comment">//truecom.mxx.juc.User@4554617c</span></span><br><span class="line">    <span class="comment">//false  com.mxx.juc.User@4554617c</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="AtomicReference存在ABA问题代码验证"><a href="#AtomicReference存在ABA问题代码验证" class="headerlink" title="AtomicReference存在ABA问题代码验证"></a>AtomicReference存在ABA问题代码验证</h2><p>demo</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference&lt;Integer&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ABA问题验证：</span></span><br><span class="line"><span class="comment"> * 1--ABA</span></span><br><span class="line"><span class="comment"> * 2--A,C</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ABADemo abaDemo = <span class="keyword">new</span> ABADemo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        abaDemo.atomicReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">        abaDemo.atomicReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;,<span class="string">"1"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="comment">// 睡1s等线程1执行完ABA</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(abaDemo.atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2020</span>)+<span class="string">"\t"</span>+abaDemo.atomicReference.get());</span><br><span class="line">        <span class="comment">//true  2020</span></span><br><span class="line"></span><br><span class="line">    &#125;,<span class="string">"2"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="AtomicStampReference解决ABA问题代码验证"><a href="#AtomicStampReference解决ABA问题代码验证" class="headerlink" title="AtomicStampReference解决ABA问题代码验证"></a>AtomicStampReference解决ABA问题代码验证</h2><p>解决思路：每次变量更新的时候，把变量的版本号加一，这样只要变量被某一个线程修改过，该变量版本号就会发生递增操作，从而解决了ABA变化</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ABAProblem();</span></span><br><span class="line">    ABADemo abaDemo = <span class="keyword">new</span> ABADemo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="comment">// 等线程2读到初始版本号的值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">"线程1在ABA前的版本号："</span>+abaDemo.atomicStampedReference.getStamp());</span><br><span class="line">        abaDemo.atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,abaDemo.atomicStampedReference.getStamp(),abaDemo.atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">        abaDemo.atomicStampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,abaDemo.atomicStampedReference.getStamp(),abaDemo.atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"线程1在ABA后的版本号："</span>+abaDemo.atomicStampedReference.getStamp());</span><br><span class="line">    &#125;,<span class="string">"1"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="comment">// 存一下修改前的版本号</span></span><br><span class="line">        <span class="keyword">int</span> stamp = abaDemo.atomicStampedReference.getStamp();</span><br><span class="line">        System.out.println(<span class="string">"线程2在修改操作前的版本号："</span>+stamp);</span><br><span class="line">        <span class="comment">// 睡1s等线程1执行完ABA</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(abaDemo.atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">2020</span>,stamp,abaDemo.atomicStampedReference.getStamp()+<span class="number">1</span>)+ <span class="string">"\t"</span> + abaDemo.atomicStampedReference.getReference());</span><br><span class="line">        <span class="comment">//线程2在修改操作前的版本号：1</span></span><br><span class="line">        <span class="comment">//线程1在ABA前的版本号：1</span></span><br><span class="line">        <span class="comment">//线程1在ABA后的版本号：3</span></span><br><span class="line">        <span class="comment">//false 100</span></span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">"2"</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="集合类不安全"><a href="#集合类不安全" class="headerlink" title="集合类不安全"></a>集合类不安全</h1><h2 id="ArrayList线程不安全演示-什么故障？什么原因？怎么解决？"><a href="#ArrayList线程不安全演示-什么故障？什么原因？怎么解决？" class="headerlink" title="ArrayList线程不安全演示-什么故障？什么原因？怎么解决？"></a>ArrayList线程不安全演示-什么故障？什么原因？怎么解决？</h2><p>ArrayList底层是一个数组，默认大小10，超过就扩容，扩原值的一半10+5=15</p>
<p>线程不安全，因为add方法没有加锁。</p>
<p>不安全案例：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerNotSafeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 故障</span></span><br><span class="line"><span class="comment">     *      java.util.ConcurrentModificationException   并发修改异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 原因</span></span><br><span class="line"><span class="comment">     *      线程并发修改导致，线程1正在写入，线程2抢占资源，导致数据不一致。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. 解决</span></span><br><span class="line"><span class="comment">     *      1 new Vector(); add方法加锁，线程安全，并发性差。</span></span><br><span class="line"><span class="comment">     *      2 Collections.synchronizedList(new ArrayList&lt;&gt;()); 包装成安全的，还是加锁，并发性差。</span></span><br><span class="line"><span class="comment">     *      3 new CopyOnWriteArrayList&lt;&gt;();  juc的类，写时复制</span></span><br><span class="line"><span class="comment">     * 4. 优化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line">        List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="CopyOnWriteArrayList原理？它有什么好？"><a href="#CopyOnWriteArrayList原理？它有什么好？" class="headerlink" title="CopyOnWriteArrayList原理？它有什么好？"></a>CopyOnWriteArrayList原理？它有什么好？</h2><p>参考：<a href="https://blog.csdn.net/linsongbin1/article/details/54581787" target="_blank" rel="noopener">https://blog.csdn.net/linsongbin1/article/details/54581787</a></p>
<p>add源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 2. 拷贝数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 新增元素到新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 4. 将array引用指向新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>解释写时复制：</p>
<ol>
<li>写操作时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。整个add操作都是在<strong>锁的保护下进行的</strong>。</li>
<li>读操作时，如果写完成且引用指向新数组，则读到的是最新数据；否则读到的是原始数组数据。可见<strong>读操作是不加锁的</strong>。</li>
</ol>
<h2 id="CopyOnWriteArrayList-缺点-amp-使用场合"><a href="#CopyOnWriteArrayList-缺点-amp-使用场合" class="headerlink" title="CopyOnWriteArrayList 缺点&amp;使用场合"></a>CopyOnWriteArrayList 缺点&amp;使用场合</h2><ol>
<li><strong>消耗内存</strong>。写操作，拷贝数组，消耗内存，数组大的话可能导致gc</li>
<li><strong>不能实时读</strong>。拷贝新增需要时间，读到的可能是旧数据，能保证最终一致性，但不满足实时要求。</li>
</ol>
<p>因此，适合<strong>读多写少</strong>的场景。</p>
<h2 id="CopyOnWriteArrayList透露的思想"><a href="#CopyOnWriteArrayList透露的思想" class="headerlink" title="CopyOnWriteArrayList透露的思想"></a>CopyOnWriteArrayList透露的思想</h2><ol>
<li>读写分离，提高并发</li>
<li>最终一致性</li>
<li>通过另辟空间，来解决并发冲突</li>
</ol>
<h2 id="集合类不安全之Set-演示-故障-解决"><a href="#集合类不安全之Set-演示-故障-解决" class="headerlink" title="集合类不安全之Set-演示/故障/解决"></a>集合类不安全之Set-演示/故障/解决</h2><p>Set同理</p>
<p>HashSet &gt; Collections.synchronizedSet() &gt; CopyOnWriteArraySet</p>
<p>且CopyOnWriteArraySet底层还是用的CopyOnWriteArrayList</p>
<p>HashSet底层是HashMap, add(key,一个常量)</p>
<h2 id="集合类不安全之Map-演示-故障-解决"><a href="#集合类不安全之Map-演示-故障-解决" class="headerlink" title="集合类不安全之Map-演示/故障/解决"></a>集合类不安全之Map-演示/故障/解决</h2><p>Map类似</p>
<p>HashMap &gt; Collections.synchronizedMap() &gt; ConcurrentHashMap</p>
<h2 id="HashMap底层实现原理-jdk7"><a href="#HashMap底层实现原理-jdk7" class="headerlink" title="HashMap底层实现原理-jdk7"></a>HashMap底层实现原理-jdk7</h2><p>可参考：</p>
<ul>
<li><p>2018/10/30/20181030111752438/#10-4-HashMap与ConcurrentHashMap解析</p>
</li>
<li><p>HashMap源码分析：<a href="https://blog.csdn.net/weixin_36910300/article/details/79985197" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36910300/article/details/79985197</a></p>
</li>
</ul>
<p><strong>map的存储结构是什么？</strong></p>
<ol>
<li>Hash表（数组+链表）</li>
<li>key-value构成一个entry对象</li>
<li>数组容量：默认16，始终保持 2^n（为了存取高效，减少碰撞，数据分配均匀）</li>
</ol>
<p><strong>new HashMap&lt;&gt;()底层发生了什么？</strong></p>
<p>创建了长度=16的 Entry table。</p>
<p><strong>源码分析</strong></p>
<ul>
<li>capacity : 当前数组容量</li>
<li>loadFactor：负载因子，默认为 0.75。</li>
<li>threshold：扩容的阈值，等于 capacity * loadFactor。当元素个数超过这个值就触发扩容。</li>
<li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30：最大的容量为 2 ^ 30</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用无参构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认初始容量大小为16,默认的加载因子为0.75f</span></span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始容量不能小于0</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//初始容量不能超过MAXIMUM_CAPACITY</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//加载因子不能小于等于0,或者加载因子不能是非数字   </span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">//设置加载因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//设置临界值</span></span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//伪构造,里面没有代码</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>map.put(key1,value1)底层发生了什么？</strong></p>
<ol>
<li>求key1的hash值，调用hashCode()，该hash值用来计算Entry数组下标，得到存放位置。</li>
<li>如果该位置为空，则添加成功。</li>
<li>如果不为空，意味着该位置存在链表：<ol>
<li>如果hash值与其他key不同，则添加成功。</li>
<li>如果key1的hash值有key与之相同，则调用equal()，继续比较：<ol>
<li>如果equal返回false，则添加成功。</li>
<li>如果equal返回true，则使用value1替换旧值（修改操作）</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>map.get(key1)底层发生了什么？</strong></p>
<ol>
<li>根据key1计算hash，找到对应数组下标。</li>
<li>遍历该位置处的链表，找到key1.equal(key2)为true的entry，返回其value。</li>
</ol>
<p><strong>扩容的原理？</strong></p>
<p>扩容后，数组大小为原来的 2 倍。</p>
<h2 id="ConcurrentHashMap底层原理-jdk7"><a href="#ConcurrentHashMap底层原理-jdk7" class="headerlink" title="ConcurrentHashMap底层原理-jdk7"></a>ConcurrentHashMap底层原理-jdk7</h2><p>关键词：Segment数组/基于分段锁/提高并发</p>
<ol>
<li><p>引入一个Segment数组。每个Segment单元都包含一个与HashMap结构差不多hash表</p>
</li>
<li><p>读取过程：</p>
<ol>
<li>先取key的hash值，取高sshift位决定属于哪个Segment单元。</li>
<li>接着就是HashMap那一套</li>
</ol>
</li>
<li><p>Segment继承jucReetrantLock，上锁方便，即分段锁。因此segment[1]锁了，不影响其他Segment单元并发。</p>
</li>
</ol>
<h2 id="HashMap底层实现原理-jdk8"><a href="#HashMap底层实现原理-jdk8" class="headerlink" title="HashMap底层实现原理-jdk8"></a>HashMap底层实现原理-jdk8</h2><p>与jdk7的不同的地方：</p>
<ol>
<li><p>new HashMap()时，不创建长度为16的数组。</p>
</li>
<li><p>底层使用Node[], 而不是Entry[]</p>
</li>
<li><p>数组结构采用</p>
<p>数组+链表+红黑树</p>
<ol>
<li>触发时机：当某索引位置链表长度&gt;8 且 数组长度&gt;64时，次索引位置的链表改为红黑树</li>
<li>红黑树的关键性质: 从根到叶子最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。</li>
<li>目的：加快检索速度</li>
</ol>
</li>
</ol>
<h2 id="ConcurrentHashMap底层原理-jdk8"><a href="#ConcurrentHashMap底层原理-jdk8" class="headerlink" title="! ConcurrentHashMap底层原理-jdk8"></a>! ConcurrentHashMap底层原理-jdk8</h2><p>参考：<a href="https://www.jianshu.com/p/5dbaa6707017" target="_blank" rel="noopener">https://www.jianshu.com/p/5dbaa6707017</a></p>
<p>底层结构</p>
<ul>
<li>和 1.8 HashMap 结构类似，也是数组+链表+红黑树的。<strong>取消了Segment 分段锁</strong></li>
</ul>
<p>那如何保证线程安全的？</p>
<ul>
<li><strong>CAS + synchronized + volatile 来保证并发安全性</strong>，具体的如下</li>
</ul>
<p>put方法逻辑</p>
<p>源代码解析：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//1. 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//2. 判断Node[]数组是否初始化，没有则进行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//3. 通过hash定位数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头节点），添加失败则进入下次循环。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 检查到内部正在扩容，就帮助它一块扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 如果该坐标Node不为null且没有正在扩容，就加锁，进行链表/红黑树 节点添加操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//5. 当前为链表，在链表中插入新的键值对</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 6.当前为红黑树，将新的键值对插入到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7.判断链表长度已经达到临界值8（默认值），当节点超过这个值就需要把链表转换为树结构</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容 </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>解析：对当前的table进行<strong>无条件自循环直到put成功（cas自旋）</strong>。</p>
<ol>
<li>如果数组下标没有Node节点，就用<strong>CAS+自旋</strong>添加链表头节点。</li>
<li>如果有Node节点，就加synchronized，添加链表或红黑树节点。</li>
</ol>
<p>get操作，由于数组被volatile修饰了，因此不用担心数组的可见性问题。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></div>



<h2 id="Map类的各种对比"><a href="#Map类的各种对比" class="headerlink" title="Map类的各种对比"></a>Map类的各种对比</h2><ul>
<li>HashMap和ConcurrentHashMap对比</li>
<li>HashMap和HashTable的对比</li>
<li>HashTable和ConcurrentHashMap对比</li>
</ul>
<h1 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h1><h2 id="Java-15锁，列举一些？"><a href="#Java-15锁，列举一些？" class="headerlink" title="Java 15锁，列举一些？"></a>Java 15锁，列举一些？</h2><p>1.公平锁 / 非公平锁<br>2.可重入锁 / 不可重入锁<br>3.独享锁 / 共享锁<br>4.互斥锁 / 读写锁<br>5.乐观锁 / 悲观锁<br>6.分段锁<br>7.偏向锁 / 轻量级锁 / 重量级锁<br>8.自旋锁</p>
<h2 id="公平和非公平锁是什么？两者区别（优缺点）？两种锁举例？"><a href="#公平和非公平锁是什么？两者区别（优缺点）？两种锁举例？" class="headerlink" title="公平和非公平锁是什么？两者区别（优缺点）？两种锁举例？"></a>公平和非公平锁是什么？两者区别（优缺点）？两种锁举例？</h2><p>是什么？</p>
<ul>
<li>公平锁：多个线程按照申请锁的顺序来获取锁。</li>
<li>非公平锁：多个线程获取锁的顺序不是按照申请舒顺序来的，有可能后申请的线程比先申请的线程优先获取锁。<pre><code>高并发下，有可能造成优先级反转或者饥饿现象。</code></pre></li>
</ul>
<p>区别：</p>
<ul>
<li>公平锁：保证顺序（队列，FIFO），性能下降。</li>
<li>非公平：先尝试直接占有锁，如果尝试失败，再采用类似公平锁的方式。优点在于吞吐量比公平锁大。</li>
</ul>
<p>举例：</p>
<ul>
<li>ReentrantLock可以指定创建公平锁或非公平锁，无参构造默认创建非公平锁。</li>
<li>synchronized是非公平的。</li>
</ul>
<h2 id="可重入锁是什么？与不可重入的区别？可重入锁举例？作用？实现原理？"><a href="#可重入锁是什么？与不可重入的区别？可重入锁举例？作用？实现原理？" class="headerlink" title="可重入锁是什么？与不可重入的区别？可重入锁举例？作用？实现原理？"></a>可重入锁是什么？与不可重入的区别？可重入锁举例？作用？实现原理？</h2><p>是什么？</p>
<ul>
<li>也叫递归锁</li>
<li>当一个线程获取某个对象锁后，可以再次获取同一把对象锁。</li>
<li>即，线程可进入任何他所拥有的对象锁所同步着的代码块。</li>
</ul>
<p>区别？</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      m1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>可重入锁：某线程进入外层m1后，可以再次进入递归m1方法。也叫递归锁。</li>
<li>不可重入锁：某线程进入外部m1后，不可再进如内部m1，必须等待锁释放。这里就造成了死锁。</li>
</ul>
<p>举例：</p>
<ul>
<li>ReentrantLock/synchronized就是典型的可重入锁</li>
</ul>
<p>作用：</p>
<ul>
<li>避免死锁。案例：递归</li>
</ul>
<p>实现原理：</p>
<ul>
<li>计数器：进入最外层计数器=1，每递归一次，计数器+1，每退出一层，计数器-1，直到计数器=0，说明退出了最外层，此时该线程释放锁对象，其他线程才能获取该锁。</li>
</ul>
<h2 id="可重入锁代码验证"><a href="#可重入锁代码验证" class="headerlink" title="可重入锁代码验证"></a>可重入锁代码验证</h2><p>synchronized</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"----m1----"</span>);</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"----m2----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以看出，m1,m2是同一把锁，只有线程释放最外层锁，其他线程才能占用该锁。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedLockDemo rd = <span class="keyword">new</span> SynchronizedLockDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                rd.m1();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0----m1----</span></span><br><span class="line">    <span class="comment">//0----m2----</span></span><br><span class="line">    <span class="comment">//4----m1----</span></span><br><span class="line">    <span class="comment">//4----m2----</span></span><br><span class="line">    <span class="comment">//3----m1----</span></span><br><span class="line">    <span class="comment">//3----m2----</span></span><br><span class="line">    <span class="comment">//2----m1----</span></span><br><span class="line">    <span class="comment">//2----m2----</span></span><br><span class="line">    <span class="comment">//1----m1----</span></span><br><span class="line">    <span class="comment">//1----m2----</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>ReentrantLock</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"----m1----"</span>);</span><br><span class="line">            m2();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"----m2----"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁要成对出现，否则：</span></span><br><span class="line"><span class="comment">     *  - 多一个lock.lock()会造成锁无法释放,程序卡住</span></span><br><span class="line"><span class="comment">     *  - 多一个lock.unlock()直接报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockDemo rd = <span class="keyword">new</span> ReentrantLockDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                rd.m1();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//0----m1----</span></span><br><span class="line">        <span class="comment">//0----m2----</span></span><br><span class="line">        <span class="comment">//2----m1----</span></span><br><span class="line">        <span class="comment">//2----m2----</span></span><br><span class="line">        <span class="comment">//1----m1----</span></span><br><span class="line">        <span class="comment">//1----m2----</span></span><br><span class="line">        <span class="comment">//3----m1----</span></span><br><span class="line">        <span class="comment">//3----m2----</span></span><br><span class="line">        <span class="comment">//4----m1----</span></span><br><span class="line">        <span class="comment">//4----m2----</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="自旋锁是什么？优点？缺点？"><a href="#自旋锁是什么？优点？缺点？" class="headerlink" title="自旋锁是什么？优点？缺点？"></a>自旋锁是什么？优点？缺点？</h2><ul>
<li>自旋锁（spinlock）是指尝试获取锁的对象不会立即阻塞，而是采用循环的方式取尝试获取锁。好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</li>
</ul>
<h2 id="手写一个自旋锁"><a href="#手写一个自旋锁" class="headerlink" title="手写一个自旋锁"></a>手写一个自旋锁</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手写自旋锁</span></span><br><span class="line"><span class="comment">     * 自旋锁的核心：while+cas+原子引用线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A线程加锁，一顿操作5秒钟，解锁。B线程一直自旋等待A线程释放锁，然后获取锁。</span></span><br><span class="line"><span class="comment">     * 打印结果：</span></span><br><span class="line"><span class="comment">     * A尝试获取锁</span></span><br><span class="line"><span class="comment">     * A成功获取锁</span></span><br><span class="line"><span class="comment">     * A一顿操作5秒...</span></span><br><span class="line"><span class="comment">     * B尝试获取锁</span></span><br><span class="line"><span class="comment">     * A释放锁</span></span><br><span class="line"><span class="comment">     * B成功获取锁</span></span><br><span class="line"><span class="comment">     * B一顿操作</span></span><br><span class="line"><span class="comment">     * B释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLockDemo sDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            sDemo.myLock();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"一顿操作5秒..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">5</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">            sDemo.myUnLock();</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证线程A先上的锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            sDemo.myLock();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"一顿操作"</span>);</span><br><span class="line"></span><br><span class="line">            sDemo.myUnLock();</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AtomicReference atomicThreadRef = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 线程A进来，发现是null值，成功操作cas把自己放进去</span></span><br><span class="line">        <span class="comment">// 线程B进来，发现不是null值，一直自旋等待线程A释放锁</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"尝试获取锁"</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicThreadRef.compareAndSet(<span class="keyword">null</span>,Thread.currentThread()))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功获取锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 线程A发现原子引用是自己，于是cas成功修改为null值，即释放锁</span></span><br><span class="line">        atomicThreadRef.compareAndSet(Thread.currentThread(),<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"释放锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="独占锁和共享锁是什么？举例？优缺点比较？"><a href="#独占锁和共享锁是什么？举例？优缺点比较？" class="headerlink" title="独占锁和共享锁是什么？举例？优缺点比较？"></a>独占锁和共享锁是什么？举例？优缺点比较？</h2><p>是什么？</p>
<ul>
<li>独占锁：写锁，该锁只能被一个线程所持有。</li>
<li>共享锁：读锁，该锁可被多个线程所持有。</li>
</ul>
<p>举例</p>
<ul>
<li>ReentrantLock和sychronized都是独占锁。</li>
<li>ReentrantReadWriteLock，其读锁是共享锁，写锁是独占锁。</li>
</ul>
<p>优缺：</p>
<ul>
<li>共享锁保证并发读是非常高效的；读写、写读、写写过程是互斥的。</li>
</ul>
<h2 id="验证读写锁ReentrantReadWriteLock"><a href="#验证读写锁ReentrantReadWriteLock" class="headerlink" title="验证读写锁ReentrantReadWriteLock"></a>验证读写锁ReentrantReadWriteLock</h2><p>并发读写不安全演示</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteUnsafeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPut</span><span class="params">(Integer key, String value)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"正在写入："</span>+key);</span><br><span class="line">        map.put(key ,value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"写入完成："</span>+key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myGet</span><span class="params">(Integer key)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"正在读取："</span>+key);</span><br><span class="line">        String value = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"读取完成："</span>+key+<span class="string">","</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发读写不安全演示</span></span><br><span class="line"><span class="comment">     * 打印：</span></span><br><span class="line"><span class="comment">     * 0	正在写入：0</span></span><br><span class="line"><span class="comment">     * 2	正在写入：2</span></span><br><span class="line"><span class="comment">     * 4	正在写入：4</span></span><br><span class="line"><span class="comment">     * 3	正在写入：3</span></span><br><span class="line"><span class="comment">     * 1	正在写入：1</span></span><br><span class="line"><span class="comment">     * 3	写入完成：3</span></span><br><span class="line"><span class="comment">     * 0	正在读取：0</span></span><br><span class="line"><span class="comment">     * 4	写入完成：4</span></span><br><span class="line"><span class="comment">     * 0	读取完成：0,0</span></span><br><span class="line"><span class="comment">     * 2	写入完成：2</span></span><br><span class="line"><span class="comment">     * 0	写入完成：0</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     * 结论：写入不是原子操作，线程不安全</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 只锁put不锁get会发生什么？</span></span><br><span class="line"><span class="comment">     * 2	正在写入</span></span><br><span class="line"><span class="comment">     * 0	正在读取</span></span><br><span class="line"><span class="comment">     * 2	写入完成：2</span></span><br><span class="line"><span class="comment">     * 造成写时读，不安全。没有保证写的原子性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReadWriteUnsafeDemo demo = <span class="keyword">new</span> ReadWriteUnsafeDemo();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                demo.myPut(tmp,String.valueOf(tmp));</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                demo.myGet(tmp);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>验证读写锁ReentrantReadWriteLock</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存资源都加一下volatile，保证线程间可见</span></span><br><span class="line">    <span class="keyword">volatile</span> Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPut</span><span class="params">(Integer key, String value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"正在写入"</span>);</span><br><span class="line">            map.put(key ,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"写入完成："</span>+key);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myGet</span><span class="params">(Integer key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"正在读取"</span>);</span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"读取完成："</span>+value);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要求：</span></span><br><span class="line"><span class="comment">     * - 读可并发</span></span><br><span class="line"><span class="comment">     * - 写和任何操作互斥</span></span><br><span class="line"><span class="comment">     * 核心：ReentrantReadWriteLock + volatile</span></span><br><span class="line"><span class="comment">     * 打印：</span></span><br><span class="line"><span class="comment">     * 2	正在写入</span></span><br><span class="line"><span class="comment">     * 2	写入完成：2</span></span><br><span class="line"><span class="comment">     * 3	正在写入</span></span><br><span class="line"><span class="comment">     * 3	写入完成：3</span></span><br><span class="line"><span class="comment">     * 4	正在写入</span></span><br><span class="line"><span class="comment">     * 4	写入完成：4</span></span><br><span class="line"><span class="comment">     * 4	正在读取</span></span><br><span class="line"><span class="comment">     * 2	正在读取</span></span><br><span class="line"><span class="comment">     * 1	正在读取</span></span><br><span class="line"><span class="comment">     * 1	读取完成：1</span></span><br><span class="line"><span class="comment">     * 3	正在读取</span></span><br><span class="line"><span class="comment">     * 结论：读写锁保证了写原子性，读并发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReadWriteLockDemo demo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                demo.myPut(tmp,String.valueOf(tmp));</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                demo.myGet(tmp);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="什么是乐观锁-悲观锁？举例？"><a href="#什么是乐观锁-悲观锁？举例？" class="headerlink" title="什么是乐观锁/悲观锁？举例？"></a>什么是乐观锁/悲观锁？举例？</h2><p>悲观锁</p>
<ul>
<li>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，Java中synchronized和ReentrantLock等<strong>独占锁就是悲观锁思想的实现</strong>。</li>
</ul>
<p>乐观锁</p>
<ul>
<li>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，采用版本号+cas的方式去保证线程安全。乐观锁适用于多读写少的应用类型，这样可以提高吞吐量。atomic包的类就是基于cas实现乐观锁的。</li>
</ul>
<h2 id="什么是乐观读-悲观读？"><a href="#什么是乐观读-悲观读？" class="headerlink" title="什么是乐观读/悲观读？"></a>什么是乐观读/悲观读？</h2><ul>
<li>悲观读：在没有任何读写锁的时候才能取得写入的锁，可用于实现悲观读取（读优先，没有读时才能写），读多写少的场景下可能会出现线程饥饿。 </li>
<li>乐观读：如果读多写少，就乐观的认为读写同时发生的情况少，因此不采用完全锁定的方式，而是采用cas实现乐观锁。</li>
</ul>
<h2 id="ReentrantReadWriteLock是乐观读还是悲观读？"><a href="#ReentrantReadWriteLock是乐观读还是悲观读？" class="headerlink" title="ReentrantReadWriteLock是乐观读还是悲观读？"></a>ReentrantReadWriteLock是乐观读还是悲观读？</h2><p>读优先：在没有任何读写锁的时候才能取得写入的锁，可用于实现悲观读取（读优先，没有读时才能写），读多写少的场景下可能会出现线程饥饿。</p>
<h2 id="StempedLock作用？"><a href="#StempedLock作用？" class="headerlink" title="StempedLock作用？"></a>StempedLock作用？</h2><p>参考：blog/2018/10/27/20181027234153307/#7-5-ReentrantLock与锁</p>
<p>它控制锁有三种模式（写、悲观读、乐观读）。</p>
<p>核心代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"><span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></span><br><span class="line"><span class="comment">// stamp=0表示没有写锁入侵，</span></span><br><span class="line"><span class="keyword">long</span> stamp = sl.readLock(); <span class="comment">// 获取悲观读锁</span></span><br><span class="line"><span class="keyword">long</span> stamp = lock.writeLock();<span class="comment">// 获得写锁</span></span><br></pre></td></tr></table></figure></div>



</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Machine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://machine4869.gitee.io/2020/02/21/20200221192831555/">https://machine4869.gitee.io/2020/02/21/20200221192831555/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://machine4869.gitee.io">哑舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/">Java面试笔试    </a></div><div class="post_share"><div class="social-share" data-image="/img/default_p12.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/02/15/20200215102406916/"><img class="next_cover lazyload" data-src="/img/default_p11.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>JVM</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/02/15/20200215102406916/" title="JVM"><img class="relatedPosts_cover lazyload"data-src="/img/default_p11.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-15</div><div class="relatedPosts_title">JVM</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'yPVvDIaWlODDhs0bbECwLIIp-gzGzoHsz',
  appKey:'VyOIa40LxnjURzW1HUCiwTpV',
  placeholder:'记得留下你的昵称及邮箱，以便收到答复~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Machine</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://machine4869.gitee.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="215,215,215" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>