<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>并发编程与线程安全（1）：并发基础知识 | 哑舍</title><meta name="description" content="并发编程与线程安全（1）：并发基础知识"><meta name="keywords" content="Java并发编程与高并发解决方案"><meta name="author" content="Machine"><meta name="copyright" content="Machine"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/cat2.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="并发编程与线程安全（1）：并发基础知识"><meta name="twitter:description" content="并发编程与线程安全（1）：并发基础知识"><meta name="twitter:image" content="https://machine4869.gitee.io/img/default_p7.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="并发编程与线程安全（1）：并发基础知识"><meta property="og:url" content="https://machine4869.gitee.io/2018/07/27/15326929363424/"><meta property="og:site_name" content="哑舍"><meta property="og:description" content="并发编程与线程安全（1）：并发基础知识"><meta property="og:image" content="https://machine4869.gitee.io/img/default_p7.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://machine4869.gitee.io/2018/07/27/15326929363424/"><link rel="prev" title="使用git将初始化代码托管到-项目初始化" href="https://machine4869.gitee.io/2018/07/28/15327623035290/"><link rel="next" title="bootdo已实现(2)" href="https://machine4869.gitee.io/2018/07/22/15328488958205/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://machine4869.gitee.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">哑舍</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 豆瓣电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片墙</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">134</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">45</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 豆瓣电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片墙</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第1章-课程准备"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">第1章 课程准备</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-1-课程导学"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">1-1 课程导学</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-2-并发编程初体验"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">1-2 并发编程初体验</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-3-并发与高并发基本概念"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">1-3 并发与高并发基本概念</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第2章-并发基础"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">第2章 并发基础</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-1-CPU多级缓存-缓存一致性"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">2-1 CPU多级缓存-缓存一致性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-2-CPU多级缓存-乱序执行优化"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">2-2 CPU多级缓存-乱序执行优化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-3-JAVA内存模型（JMM）"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">2-3 JAVA内存模型（JMM）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-4-并发的优势与风险"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">2-4 并发的优势与风险</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第1章-课程准备"><span class="toc-number">1.</span> <span class="toc-text">第1章 课程准备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-课程导学"><span class="toc-number">1.1.</span> <span class="toc-text">1-1 课程导学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-并发编程初体验"><span class="toc-number">1.2.</span> <span class="toc-text">1-2 并发编程初体验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-并发与高并发基本概念"><span class="toc-number">1.3.</span> <span class="toc-text">1-3 并发与高并发基本概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第2章-并发基础"><span class="toc-number">2.</span> <span class="toc-text">第2章 并发基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-CPU多级缓存-缓存一致性"><span class="toc-number">2.1.</span> <span class="toc-text">2-1 CPU多级缓存-缓存一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-CPU多级缓存-乱序执行优化"><span class="toc-number">2.2.</span> <span class="toc-text">2-2 CPU多级缓存-乱序执行优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-JAVA内存模型（JMM）"><span class="toc-number">2.3.</span> <span class="toc-text">2-3 JAVA内存模型（JMM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-并发的优势与风险"><span class="toc-number">2.4.</span> <span class="toc-text">2-4 并发的优势与风险</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/default_p7.jpeg)"><div id="post-info"><div id="post-title"><div class="posttitle">并发编程与线程安全（1）：并发基础知识</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2018-07-27<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2019-11-28</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">Java并发编程与高并发解决方案</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.2k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 16 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2018/07/27/15326929363424/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2018/07/27/15326929363424/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><blockquote>
<p>参考视频：慕课网【Java并发编程与高并发解决方案】<br>参考笔记：<a href="https://blog.csdn.net/qq_28867949/article/details/80045280" target="_blank" rel="noopener">https://blog.csdn.net/qq_28867949/article/details/80045280</a></p>
<p>代码地址：<a href="https://gitee.com/machine4869/example-code/tree/master/node_concurrency" target="_blank" rel="noopener">node_concurrency</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="第1章-课程准备"><a href="#第1章-课程准备" class="headerlink" title="第1章 课程准备"></a>第1章 课程准备</h1><h2 id="1-1-课程导学"><a href="#1-1-课程导学" class="headerlink" title="1-1 课程导学"></a>1-1 课程导学</h2><p>并发编程&amp;高并发解决方案</p>
<h2 id="1-2-并发编程初体验"><a href="#1-2-并发编程初体验" class="headerlink" title="1-2 并发编程初体验"></a>1-2 并发编程初体验</h2><p>问题引入：计数功能，同一时间多个进程同时对一个变量计数（并发）,计数会变少（for5000次的结果会小于5000）。</p>
<h2 id="1-3-并发与高并发基本概念"><a href="#1-3-并发与高并发基本概念" class="headerlink" title="1-3 并发与高并发基本概念"></a>1-3 并发与高并发基本概念</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">并发：</span><br><span class="line">同时拥有两个或者多个线程，如果程序在单核处理器上运行多个线程将交替地换入或者换出内存，这些线程是</span><br><span class="line">同时“存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都</span><br><span class="line">将分配到一个处理器核上，因此可以同时运行。</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">高并发: </span><br><span class="line">高并发( High Concurrency) 是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计</span><br><span class="line">保证系统能够&quot;同时并行处理&quot;很多请求</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对比：</span><br><span class="line">并发：多个线程操作相同的资源，保证线程安全，合理使用资源</span><br><span class="line">高并发：服务能同时处理很多请求，提高程序性能</span><br></pre></td></tr></table></figure></div>

<h1 id="第2章-并发基础"><a href="#第2章-并发基础" class="headerlink" title="第2章 并发基础"></a>第2章 并发基础</h1><h2 id="2-1-CPU多级缓存-缓存一致性"><a href="#2-1-CPU多级缓存-缓存一致性" class="headerlink" title="2-1 CPU多级缓存-缓存一致性"></a>2-1 CPU多级缓存-缓存一致性</h2><p><strong>多级缓存</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    数据的读取和存储都经过高速缓存，CPU核心与高速缓存有一条特殊的快速通道。主存与高速缓存都是连接</span><br><span class="line">在系统总线上（Bus），这条总线同时还用于其他组件的通信...</span><br><span class="line">    在高速缓存出现后不久，系统变得愈加复杂，高速缓存与主存之间的速度差异被拉大，直到加入了另一级</span><br><span class="line">缓存（L2 Cache），新加入的这级缓存比第一缓存更大、更慢。由于加大缓存的方法从经济利益的角度考虑是</span><br><span class="line">行不通的，所以这才有了二级缓存，甚至现在有些系统拥有三级缓存。</span><br></pre></td></tr></table></figure></div>

<p><a href="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%881.44.49.png" data-fancybox="group" data-caption="屏幕快照 2018-07-28 下午1.44.49" class="fancybox"><img alt="屏幕快照 2018-07-28 下午1.44.49" title="屏幕快照 2018-07-28 下午1.44.49" data-src="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%881.44.49.png" class="lazyload"></a></p>
<p><code>&quot;左图为高速缓存  右图为多级缓存&quot;</code></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU高速缓存（英语：CPU Cache，在本文中简称缓存）是用于减少处理器访问内存所需平均时间的部件。</span><br><span class="line">在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近处</span><br><span class="line">理器的频率。</span><br></pre></td></tr></table></figure></div>

<p>为什么需要CPU Cache？</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU 的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。</span><br><span class="line">所以cache 的出现，是为了缓解 CPU 和内存之间速度的不匹配问题</span><br><span class="line">结构：cpu-&gt; cache-&gt; memory).</span><br></pre></td></tr></table></figure></div>

<p>CPU Cache有什么意义？</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) 时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问</span><br><span class="line">2) 空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问</span><br></pre></td></tr></table></figure></div>

<hr>
<p> <strong>缓存一致性（MESI）</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理器上有一套完整的协议，来保证Cache一致性。比较经典的Cache一致性协议当属MESI协议，奔腾处理器有使用它，很多其他的处理器都是使用它的变种。</span><br><span class="line"></span><br><span class="line">单核Cache中每个Cache line有2个标志：dirty和valid标志，它们很好的描述了Cache和Memory(内存)之间的数据关系(数据是否有效，数据是否被修改)，而在多核处理器中，多个核会共享一些数据，MESI协议就包含了描述共享的状态。</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M: Modified 修改，指的是该缓存行只被缓存在该CPU的缓存中，并且是被修改过的，因此他与主存中的数据是不一致的，该缓存行中的数据需要在未来的某个时间点（允许其他CPU读取主存相应中的内容之前）写回主存，然后状态变成E（独享）</span><br><span class="line">E：Exclusive 独享 缓存行只被缓存在该CPU的缓存中，是未被修改过的，与主存的数据是一致的，可以在任何时刻当有其他CPU读取该内存时，变成S（共享）状态，当CPU修改该缓存行的内容时，变成M（被修改）的状态</span><br><span class="line">S：Share 共享，意味着该缓存行可能会被多个CPU进行缓存，并且该缓存中的数据与主存数据是一致的，当有一个CPU修改该缓存行时，其他CPU是可以被作废的，变成I(无效的)</span><br><span class="line">I：Invalid 无效的，代表这个缓存是无效的，可能是有其他CPU修改了该缓存行</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M(Modified)和E(Exclusive)状态的Cache line，数据是独有的，不同点在于M状态的数据是dirty的(和内存的不一致)，E状态的数据是clean的(和内存的一致)。</span><br><span class="line"></span><br><span class="line">S(Shared)状态的Cache line，数据和其他Core的Cache共享。只有clean的数据才能被多个Cache共享。</span><br><span class="line">I(Invalid)表示这个Cache line无效。</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>CPU多级缓存-缓存一致性（MESI）<br>具体相关概念参考博客:<a href="https://blog.csdn.net/qq_28867949/article/details/79991422" target="_blank" rel="noopener">https://blog.csdn.net/qq_28867949/article/details/79991422</a> </p>
</blockquote>
<p><a href="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%881.46.23.png" data-fancybox="group" data-caption="屏幕快照 2018-07-28 下午1.46.23" class="fancybox"><img alt="屏幕快照 2018-07-28 下午1.46.23" title="屏幕快照 2018-07-28 下午1.46.23" data-src="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%881.46.23.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在MESI协议中，每个Cache的Cache控制器不仅知道自己的读写操作，而且也监听(snoop)其它Cache的读写</span><br><span class="line">操作。每个Cache line所处的状态根据本核和其它核的读写操作在4个状态间进行迁移。</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local read：读本地缓存的数据</span><br><span class="line">local write：将数据写到本地缓存里面</span><br><span class="line">remote read：将内（主）存中的数据读取到缓存中来</span><br><span class="line">remote write：将缓存中的数据写会到主存里面</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;补充说明：&quot;</span><br><span class="line">    对于各级的Cache，访问速度是不同的，理论上说L1 Cache（一级缓存）有着跟CPU寄存器相同的速度，</span><br><span class="line">但L1 Cache有一个问题，当需要同步Cache和内存之间的内容时，需要锁住Cache的某一块（&quot;术语是Cache</span><br><span class="line"> line&quot;），然后再进行Cache或者内存内容的更新，这段期间这个Cache块是不能被访问的，所以L1 Cache</span><br><span class="line">的速度就没寄存器快，因为它会频繁的有一段时间不可用。</span><br><span class="line">    L1 Cache下面是L2 Cache，甚至L3 Cache，这些都有跟L1 Cache一样的问题，要加锁，同步，并且</span><br><span class="line">L2比L1慢，L3比L2慢，这样速度也就更低了。</span><br></pre></td></tr></table></figure></div>

<p><code>理解16种状态参见上述链接</code></p>
<p><code>总结：每个核都拥有自己的缓存，缓存一致性保证了多核存取共享数据时数据一致</code></p>
<h2 id="2-2-CPU多级缓存-乱序执行优化"><a href="#2-2-CPU多级缓存-乱序执行优化" class="headerlink" title="2-2 CPU多级缓存-乱序执行优化"></a>2-2 CPU多级缓存-乱序执行优化</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;什么是乱序执行优化&quot;：处理器为提高运算速度而做出违背代码原有顺序的优化。</span><br><span class="line"></span><br><span class="line">例如：计算 result &#x3D; a*b</span><br><span class="line">     原本我们的预期顺序是：     a&#x3D;10 --&gt; b&#x3D;200 --&gt; result&#x3D;a*b</span><br><span class="line">     实际上乱序优化后的实际顺序：b&#x3D;200 --&gt; a&#x3D;10 --&gt; result&#x3D;a*b</span><br><span class="line">&quot;结论：处理器这样优化的结果来看，得到结果不会偏离预期目标！！！</span><br><span class="line">      但是,当在多个环境下却并非如此。&quot;</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    处理器为提高运算速度而做出违背代码原有顺序的优化。当然了在正常情况下是不对结果造成影响的。在</span><br><span class="line">单核时代处理器对结果的优化保证不会远离预期目标，但是在多核环境下却并非如此。为什么这么说呢？首先，</span><br><span class="line">在多核条件下会有多个核执行指令，因此每个核的指令都有可能会乱序。另外处理器还引入了L1、L2缓存机</span><br><span class="line">制，这就导致了逻辑上后写入的数据不一定最后写入。</span><br><span class="line"></span><br><span class="line">    这就导致的一个问题，如果我们不做任何处理，实际结果可能和逻辑运行结果大不相同。在一个核上记录</span><br><span class="line">一个标志表示数据已经准备完毕，在另一个核上来判断这个数据是否已经就绪，这时候就会存在风险。标记位先</span><br><span class="line">被写入，但是实际的操作缺并未完成，这个未完成既有可能是没有计算完成，也有可能是缓存没有被及时刷新到</span><br><span class="line">主存之中，使得其他核读到了错误的数据。</span><br></pre></td></tr></table></figure></div>

<p><code>总结：乱序执行优化，在多核条件下，会导致数据错误</code></p>
<h2 id="2-3-JAVA内存模型（JMM）"><a href="#2-3-JAVA内存模型（JMM）" class="headerlink" title="2-3 JAVA内存模型（JMM）"></a>2-3 JAVA内存模型（JMM）</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    为了屏蔽掉各种系统硬件和操作系统的内存访问差异，以实现Java程序在各大平台都能达到一致的并发效</span><br><span class="line">果，Java虚拟机因此定义了Java内存模型，它规范了Java虚拟机与计算机是如何协同工作的。</span><br><span class="line"></span><br><span class="line">    它规定了一个线程如何看到或者共享其他线程一个共享变量的值，以及必须时，如何同步的访问共享变</span><br><span class="line">量。</span><br></pre></td></tr></table></figure></div>

<p>JAVA内存模型规范（即它的作用）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 规定了一个线程如何和何时可以看到其他线程修改过后的共享变量的值</span><br><span class="line">2. 如何以及何时同步的访问共享变量</span><br></pre></td></tr></table></figure></div>

<p>JAVA内存模型：</p>
<p><a href="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%881.48.20.png" data-fancybox="group" data-caption="屏幕快照 2018-07-28 下午1.48.20" class="fancybox"><img alt="屏幕快照 2018-07-28 下午1.48.20" title="屏幕快照 2018-07-28 下午1.48.20" data-src="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%881.48.20.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Heap(堆)：Java里的堆是一个运行时的数据区，堆是由垃圾回收来负责的，堆的优势是可以动态的分配内存大</span><br><span class="line">         小，生存期也不必事先告诉编译器，他是在运行时动态分配内存的，Java的垃圾回收器会定时收走</span><br><span class="line">         不用的数据，</span><br><span class="line">    缺点：由于要在运行时动态分配，所有存取速度可能会慢一些</span><br><span class="line"></span><br><span class="line">Stack(栈)：栈的优势是存取速度比堆要快，仅次于计算机里的寄存器，栈的数据是可以共享的，</span><br><span class="line">     缺点：是存在栈数据的大小与生存期必须是确定的，缺乏一些灵活性栈中主要存放一些基本类型的</span><br><span class="line">          变量，比如:int、short、long、bytedouble、float、boolean、char、对象句柄，</span><br><span class="line"></span><br><span class="line">    Java内存模型要求调用栈和本地变量存放在线程栈（Thread Stack）上，对象存放在堆上。</span><br><span class="line">    一个本地变量可能存放一个对象的引用，这时引用变量存放在本地栈上，但是对象本身存放在堆上</span><br><span class="line">    成员变量跟随着对象存放在堆上，而不管是原始类型还是引用类型，静态成员变量跟随着类的定义一起存在在堆上</span><br><span class="line"></span><br><span class="line">    存在堆上的对象，可以被持有这个对象的引用的线程访问</span><br><span class="line">    如果两个线程同时访问同一个对象的私有变量，这时他们所拥有的是&quot;这个对象的私有拷贝&quot;(&quot;重要&quot;)</span><br></pre></td></tr></table></figure></div>

<p>计算机硬件架构的简单图示</p>
<p><a href="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%881.49.19.png" data-fancybox="group" data-caption="屏幕快照 2018-07-28 下午1.49.19" class="fancybox"><img alt="屏幕快照 2018-07-28 下午1.49.19" title="屏幕快照 2018-07-28 下午1.49.19" data-src="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%881.49.19.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;CPU：&quot;一个计算机一般有多个CPU，一个CPU还会有多核。因此意味着每个cpu可能都会运行一个线程，所以计算</span><br><span class="line">    机出现多线程是很有可能的。</span><br><span class="line"></span><br><span class="line">&quot;CPU Registers（寄存器）：&quot;每个CPU都包含一系列的寄存器，他们是CPU内存的基础，CPU在寄存器上执行的</span><br><span class="line">        速度远大于在主存上执行的速度，这是因为计算机访问寄存器的速度远大于主存。</span><br><span class="line"></span><br><span class="line">&quot;CPU Cache（高速缓存）：&quot;由于计算机的存储设备与处理器的处理设备有着几个数量级的差距，所以现代计</span><br><span class="line">    算机都会加入一层读写速度与处理器处理速度接近相同的高级缓存来作为内存与处理器之间的缓冲，将运</span><br><span class="line">    算使用到的数据复制到缓存中，让运算能够快速的执行，当运算结束后，再从缓存同步到内存之中，这</span><br><span class="line">    样，CPU就不需要等待缓慢的内存读写了主（内）存：一个计算机包含一个主存，所有的CPU都可以访问主</span><br><span class="line">    存，主存比缓存容量大的多（CPU访问缓存层的速度快于访问主存的速度！但通常比访问内存寄存器的速度还是要慢点）</span><br><span class="line"></span><br><span class="line">&quot;运作原理：&quot;通常情况下，当一个CPU要读取主存（RAM - Main Mernory）的时候，他会将主存中的数据读</span><br><span class="line">        取到CPU缓存中，甚至将缓存内容读到内部寄存器里面，然后再寄存器执行操作，当运行结束后，会</span><br><span class="line">        将寄存器中的值刷新回缓存中，并在某个时间点将值刷新回主存</span><br></pre></td></tr></table></figure></div>

<p><strong>JAVA内存模型与硬件架构之间的关联</strong></p>
<p><a href="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%881.53.07.png" data-fancybox="group" data-caption="屏幕快照 2018-07-28 下午1.53.07" class="fancybox"><img alt="屏幕快照 2018-07-28 下午1.53.07" title="屏幕快照 2018-07-28 下午1.53.07" data-src="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%881.53.07.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">每个线程之间共享变量都存放在主内存里面，每个线程都有一个私有的本地内存</span><br><span class="line">本地内存是Java内存模型中抽象的概念，并不是真实存在的（他涵盖了缓存写缓冲区。寄存器，以及其他硬件的优化）</span><br><span class="line">本地内存中存储了以读或者写共享变量的拷贝的一个副本</span><br><span class="line"></span><br><span class="line">从一个更低的层次来说，线程本地内存，他是CPU缓存，寄存器的一个抽象描述，而JVM的静态内存存储模型，</span><br><span class="line">他只是一种对内存模型的物理划分而已，只局限在内存，而且只局限在JVM的内存</span><br><span class="line"></span><br><span class="line">如果线程A和线程B要通信，必须经历两个过程：</span><br><span class="line">1、A将本地内存变量刷新到主内存</span><br><span class="line">2、B从主内存中读取变量</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>举例</p>
</li>
<li><p>下面对上面的描述举个例子。假设主内存的变量为1，线程A、B同时读取，线程A从主内存得到变量值为1，然后存储到自己的本地内存，之后进行+1的操作，最后写回主内存变为2。其实B的操作也是一样的。线程B并不是等线程A写回主内存之后再开始操作的，它们之间不可见的，因此当线程B操作完成将结果2写回主内存时计数就出现了错误，<strong>所以需要引入同步的手段保证并发准确性</strong>。</p>
</li>
</ul>
<hr>
<p><strong>Java内存模型 - 八种同步操作</strong></p>
<p><a href="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%882.06.59.png" data-fancybox="group" data-caption="屏幕快照 2018-07-28 下午2.06.59" class="fancybox"><img alt="屏幕快照 2018-07-28 下午2.06.59" title="屏幕快照 2018-07-28 下午2.06.59" data-src="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%882.06.59.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.Lock（锁定）：作用于主内存的变量，把一个变量标识变为一条线程独占状态</span><br><span class="line">2.Unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</span><br><span class="line">3.Read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</span><br><span class="line">4.Load（载入）：作用于工作内存的变量，它把Read操作从主内存中得到的变量值放入工作内存的变量副本中</span><br><span class="line">5.Use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</span><br><span class="line">6.Assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接受到的值赋值给工作内存的变量</span><br><span class="line">7.Store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</span><br><span class="line">8.Write（写入）：作用于主内存的变量，它把Store操作从工作内存中一个变量的值传送到主内存的变量中</span><br></pre></td></tr></table></figure></div>

<p>Java内存模型 - 同步规则</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.如果要把一个变量从主内存中赋值到工作内存，就需要按顺序得执行read和load操作，如果把变量从工作内</span><br><span class="line">    存中同步回主内存中，就要按顺序得执行store和write操作，但java内存模型只要求上述操作必须按顺</span><br><span class="line">    序执行，没有保证必须是连续执行,也就是说Read和Load、Store和Write之间是可以插入其他指令的</span><br><span class="line">2.不允许read和load、store和write操作之一单独出现</span><br><span class="line">3.不允许一个线程丢弃他的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中</span><br><span class="line">4.不允许一个线程无原因地（也就是说必须有assgin操作）把数据从工作内存同步到主内存中</span><br><span class="line">5.一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变</span><br><span class="line">    量。即就是对一个变量实施use和store操作之前，必须先执行过了load和assign操作</span><br><span class="line">6.一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以同时被一条线程重复执行多次，多</span><br><span class="line">    次执行lock后，只有执行相同次数的unlock操作，变量才会解锁，lock和unlock必须成对出现</span><br><span class="line">7.如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎中使用这个变量前需要重新执行</span><br><span class="line">    load或assign操作初始化变量的值</span><br><span class="line">8.如果一个变量事先没有被lock操作锁定，则不允许他执行unlock操作，也不允许去unlock一个被其他线程</span><br><span class="line">    锁定的变量</span><br><span class="line">9.对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（其实就是执行store和write操作之后）</span><br></pre></td></tr></table></figure></div>

<h2 id="2-4-并发的优势与风险"><a href="#2-4-并发的优势与风险" class="headerlink" title="2-4 并发的优势与风险"></a>2-4 并发的优势与风险</h2><p><a href="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%882.15.02.png" data-fancybox="group" data-caption="屏幕快照 2018-07-28 下午2.15.02" class="fancybox"><img alt="屏幕快照 2018-07-28 下午2.15.02" title="屏幕快照 2018-07-28 下午2.15.02" data-src="/2018/07/27/15326929363424/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%882.15.02.png" class="lazyload"></a></p>
<p>并发的优势：</p>
<ul>
<li><p>速度： </p>
<ul>
<li>系统可以同时处理多个请求，等待的时间变短，那么相应的响应更快；</li>
<li>另一方面，复杂的操作可以分成多个进程同时进程；</li>
</ul>
</li>
<li><p>设计：</p>
<ul>
<li>总结：程序设计在某些情况下更简单，也可以有更多的选择</li>
<li>举例：我们有一个应用程序需要从本地系统中读取和处理两个文件，如果你想编写程序，读取和处理数据的时候，你就必须记录哪个文件的读取和处理的状态。相反，如果你使用多线程并发处理，你就可以启动两个线程，每一个线程读取和处理一个文件的读取和操作，线程会在磁盘读取文件的过程中被阻塞，在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件，其结果就是，磁盘总是繁忙的读取文件到内存中，这回带来磁盘和CPU利用率的提升，而且每个线程只需要记录一个文件，因此这个方式也很容易被编程实现。</li>
</ul>
</li>
<li><p>资源利用： </p>
<ul>
<li>CPU能够在等待IO的时候做一些其他的事情</li>
<li>举例：依然是上面的例子，当个应用程序从本地系统中读取和处理文件，从磁盘中读取文件的时候呢，大部分的CPU，时间都用于等待磁盘去读取数据，在这段时间里CPU非常的空闲。它可以做许多事情，通过改变操作顺序更高的利用CPU资源。（这里所说的IO可以是磁盘的IO、网络的IO、或者是用户输入，通常情况下：网络和磁盘的IO比CPU和内存的IO慢很多）</li>
</ul>
</li>
</ul>
<p>并发的风险：</p>
<ul>
<li><p>安全性 </p>
<ul>
<li>总结：多个线程共享数据时可能会产生于期望不相符的结果</li>
</ul>
</li>
<li><p>活跃性 </p>
<ul>
<li>总结：某个操作无法继续进行下去时，就会发生活跃性问题。比如死锁、饥饿等问题…</li>
<li>比如：我们已经知道了，多个线程共享数据时会产生于期望不符的结果，因此我们就会尝试通过加锁等方式来保证我们得到的结果能够符合预期。这个时候呢如果加锁、解锁操作不当、或者有什么异常情况发生，这个时候可能就会引发死锁。</li>
</ul>
</li>
<li><p>性能 </p>
<ul>
<li>总结：线程过多时会使得：CPU 频繁切换，调度时间增多；同步机制；消耗过多内存</li>
<li>说明1：当 CPU 调度不同线程时，它需要更新当前执行线程的数据，程序指针，以及下一个线程的相关信息。这种切换会有额外的时间、空间消耗，我们在开发中应该避免频繁的线程切换。</li>
<li>说明2：多环境情况下必须使用同步机制，这导致了很多编译器想做的优化被抑制。线程过多还会消耗过多内存</li>
</ul>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Machine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://machine4869.gitee.io/2018/07/27/15326929363424/">https://machine4869.gitee.io/2018/07/27/15326929363424/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://machine4869.gitee.io">哑舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">Java并发编程与高并发解决方案    </a></div><div class="post_share"><div class="social-share" data-image="/img/default_p7.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/07/28/15327623035290/"><img class="prev_cover lazyload" data-src="/img/default_p10.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>使用git将初始化代码托管到-项目初始化</span></div></a></div><div class="next-post pull_right"><a href="/2018/07/22/15328488958205/"><img class="next_cover lazyload" data-src="/img/default_p12.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>bootdo已实现(2)</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2018/11/05/20181105165724309/" title="高并发解决方案（4）：数据库切库分库分表&高可用"><img class="relatedPosts_cover lazyload"data-src="/img/default_p5.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-11-05</div><div class="relatedPosts_title">高并发解决方案（4）：数据库切库分库分表&高可用</div></div></a></div><div class="relatedPosts_item"><a href="/2018/11/05/20181105104407665/" title="高并发解决方案（3）：应用限流&服务降级与服务熔断"><img class="relatedPosts_cover lazyload"data-src="/img/default_p3.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-11-05</div><div class="relatedPosts_title">高并发解决方案（3）：应用限流&服务降级与服务熔断</div></div></a></div><div class="relatedPosts_item"><a href="/2018/11/03/20181103212110299/" title="高并发解决方案（2）：消息队列&应用拆分"><img class="relatedPosts_cover lazyload"data-src="/img/default_p8.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-11-03</div><div class="relatedPosts_title">高并发解决方案（2）：消息队列&应用拆分</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/31/20181031100154042/" title="高并发解决方案（1）：扩容&缓存"><img class="relatedPosts_cover lazyload"data-src="/img/default_p4.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-31</div><div class="relatedPosts_title">高并发解决方案（1）：扩容&缓存</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/30/20181030111752438/" title="并发编程与线程安全（6）：线程池 Executor&并发拓展"><img class="relatedPosts_cover lazyload"data-src="/img/default_p6.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-30</div><div class="relatedPosts_title">并发编程与线程安全（6）：线程池 Executor&并发拓展</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/29/20181029185403603/" title="并发编程与线程安全（5）：J.U.C组件拓展"><img class="relatedPosts_cover lazyload"data-src="/img/default_p2.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-29</div><div class="relatedPosts_title">并发编程与线程安全（5）：J.U.C组件拓展</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'yPVvDIaWlODDhs0bbECwLIIp-gzGzoHsz',
  appKey:'VyOIa40LxnjURzW1HUCiwTpV',
  placeholder:'记得留下你的昵称及邮箱，以便收到答复~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Machine</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://machine4869.gitee.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="215,215,215" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>